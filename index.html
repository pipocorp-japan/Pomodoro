<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ポモドーロタイマー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font (slightly bolder weights) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Material Icons (Google Fonts) -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Chart.js for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        /* Define CSS Custom Properties for theme colors */
        :root {
            --primary-color: #ef4444; /* Default Red */
            --primary-color-dark: #dc2626; /* Darker Red for hover */
            --secondary-period-color: #10b981; /* Green for break period */
            --on-primary: #ffffff; /* Text color on primary background */
            --on-surface: #1f2937; /* Default text color on card/surface */
            --surface-color: #ffffff; /* Card/Modal background */
            --background-color: #f0f2f5; /* App background */
            --text-light: #6b7280; /* Lighter text for labels/hints */
            --outline-color: #d1d5db; /* Border color for inputs */
        }

        /* General Body and Screen Layout */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 24px;
            box-sizing: border-box;
            overflow-x: hidden;
            color: var(--on-surface);
            line-height: 1.5; /* Improved readability */
        }

        .screen {
            background-color: var(--surface-color);
            border-radius: 28px; /* Significantly more rounded corners for Material You */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1); /* Stronger, layered shadow */
            padding: 36px; /* More generous padding */
            width: 100%;
            max-width: 480px; /* Wider max-width for modern feel */
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            min-height: 520px; /* Ensure consistent card size */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* Material-like easing */
        }

        .screen.hidden {
            display: none !important;
            opacity: 0;
            transform: translateY(30px); /* Larger offset for animation */
        }
        .screen.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Timer Screen specific styles */
        #timerScreen .timer-display {
            font-size: 8rem; /* Even larger timer font */
            font-weight: 800; /* Extra bold for timer */
            color: var(--primary-color);
            margin-bottom: 32px; /* More space */
            letter-spacing: -4px; /* More pronounced letter spacing */
            line-height: 1; /* Prevent extra space above/below */
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px; /* More space between buttons */
            margin-top: 32px;
        }

        .button-primary {
            background-color: var(--primary-color);
            color: var(--on-primary);
            padding: 20px 40px; /* Larger padding */
            border-radius: 40px; /* Very rounded, FAB-like */
            font-size: 1.8rem; /* Larger font */
            font-weight: 700; /* Bolder weight */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 3px 6px rgba(0, 0, 0, 0.12); /* Stronger shadow */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: none;
            outline: none;
            white-space: nowrap;
        }

        .button-primary:hover {
            background-color: var(--primary-color-dark);
            transform: translateY(-4px); /* More pronounced lift */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25), 0 4px 8px rgba(0, 0, 0, 0.15); /* Stronger shadow on hover */
        }

        .button-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button-secondary {
            background-color: #e8eaf6; /* Light indigo background */
            color: #3f51b5; /* Indigo text color */
            padding: 18px 32px;
            border-radius: 36px;
            font-size: 1.6rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1); /* Slightly stronger shadow */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: none;
            outline: none;
            white-space: nowrap;
        }

        .button-secondary:hover {
            background-color: #c5cae9; /* Darker indigo on hover */
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
        }

        .button-secondary:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .icon-button {
            background-color: transparent;
            border: none;
            font-size: 2.8rem; /* Larger icons */
            color: var(--text-light);
            cursor: pointer;
            transition: color 0.3s ease, background-color 0.3s ease;
            outline: none;
            border-radius: 50%;
            padding: 12px; /* Larger tap area */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-button:hover {
            color: var(--on-surface);
            background-color: rgba(0, 0, 0, 0.06); /* More visible hover effect */
        }

        .icon-button.top-right {
            position: absolute;
            top: 24px; /* More space from edge */
            right: 24px;
        }

        .icon-button.top-left {
            position: absolute;
            top: 24px;
            left: 24px;
            font-size: 2.4rem; /* Slightly smaller for back button */
        }

        /* Modal / Dialog Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Darker overlay for focus */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }

        .modal-overlay.visible {
            opacity: 1;
        }

        .modal-content {
            background-color: var(--surface-color);
            padding: 32px;
            border-radius: 20px; /* Consistent rounded corners */
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 6px 12px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 500px; /* Wider modal */
            transform: translateY(30px);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-overlay.visible .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-header {
            font-size: 2rem; /* Larger header */
            font-weight: 700;
            margin-bottom: 28px; /* More space */
            color: var(--on-surface);
        }

        .modal-body label {
            display: flex;
            align-items: center;
            margin-bottom: 20px; /* More space between labels */
            font-size: 1.2rem; /* Larger font */
            color: var(--on-surface);
            font-weight: 500;
        }

        .modal-body input[type="number"],
        .modal-body input[type="color"],
        .modal-body select {
            flex-grow: 1;
            margin-left: 16px; /* More space */
            padding: 12px 16px; /* More padding */
            border: 1px solid var(--outline-color);
            border-radius: 12px; /* More rounded inputs */
            font-size: 1.1rem;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            background-color: #fcfcfc;
        }

        .modal-body input[type="color"] {
            padding: 0;
            width: 70px; /* Adjust width for color picker */
            height: 50px; /* Adjust height for color picker */
            cursor: pointer;
        }

        .modal-body input[type="number"]:focus,
        .modal-body input[type="color"]:focus,
        .modal-body select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(var(--primary-color-rgb), 0.3); /* Stronger shadow */
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 16px; /* More space */
            margin-top: 32px;
        }

        .modal-actions button {
            padding: 12px 24px;
            border-radius: 12px; /* Rounded buttons in modal */
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease, box-shadow 0.2s ease;
        }

        .modal-actions .button-cancel {
            background-color: #e0e0e0;
            color: var(--on-surface);
        }

        .modal-actions .button-cancel:hover {
            background-color: #d0d0d0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .modal-actions .button-save {
            background-color: var(--secondary-period-color);
            color: var(--on-primary);
        }

        .modal-actions .button-save:hover {
            background-color: #059669;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        /* Custom Alert Dialog */
        .custom-alert-dialog {
            background-color: var(--surface-color);
            padding: 32px;
            border-radius: 20px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 6px 12px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 450px;
            text-align: center;
        }

        .custom-alert-dialog p {
            font-size: 1.25rem; /* Larger message */
            margin-bottom: 32px;
            color: var(--on-surface);
            line-height: 1.6;
            font-weight: 500;
        }

        /* Home Screen specific styles */
        #homeScreen .current-time {
            font-size: 5rem; /* Even bigger clock */
            font-weight: 700;
            color: var(--on-surface);
            margin-top: 40px;
            margin-bottom: 60px; /* More space */
        }

        #homeScreen .home-buttons {
            display: flex;
            flex-direction: column;
            gap: 28px; /* More space between buttons */
            width: 100%;
        }

        #homeScreen .home-button {
            background-color: var(--primary-color);
            color: var(--on-primary);
            padding: 24px; /* More padding */
            border-radius: 20px; /* Consistent rounded corners */
            font-size: 2rem; /* Larger font */
            font-weight: 600;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: none;
            outline: none;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px; /* More space between icon and text */
        }

        #homeScreen .home-button .material-icons {
            font-size: 2.4rem; /* Icon size */
        }

        #homeScreen .home-button:hover {
            background-color: var(--primary-color-dark);
            transform: translateY(-4px);
            box-shadow: 0 7px 14px rgba(0, 0, 0, 0.2);
        }

        #homeScreen .home-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        /* Records Screen specific styles */
        #recordsScreen .records-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 28px;
        }

        #recordsScreen .records-header h2 {
            font-size: 2.2rem; /* Larger header */
            font-weight: 700;
            color: var(--on-surface);
            margin-left: auto;
            margin-right: auto;
        }

        #recordsScreen .records-time-unit-buttons {
            display: flex;
            justify-content: center;
            gap: 16px; /* More space */
            margin-top: 15px;
            margin-bottom: 28px;
            width: 100%;
        }

        #recordsScreen .records-time-unit-buttons button {
            background-color: #e0e0e0;
            color: var(--on-surface);
            padding: 12px 20px;
            border-radius: 12px; /* More rounded */
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            outline: none;
            transition: background-color 0.3s ease, box-shadow 0.2s ease;
        }

        #recordsScreen .records-time-unit-buttons button.active {
            background-color: var(--primary-color);
            color: var(--on-primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #recordsScreen .records-time-unit-buttons button:hover:not(.active) {
            background-color: #d0d0d0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .chart-scroll-container {
            width: 100%;
            overflow-x: auto;
            max-width: 100%;
            padding-bottom: 15px;
        }
        #recordsChartCanvas {
            width: 100% !important;
            height: 350px !important; /* Taller chart */
            min-width: 450px; /* Minimum width to prevent excessive squeezing for daily view */
        }

        /* Progress Bar styles */
        .progress-container {
            width: 95%; /* Wider progress bar */
            height: 16px; /* Thicker progress bar */
            background-color: #e5e7eb;
            border-radius: 8px; /* Matches height for full roundness */
            margin-top: 28px;
            overflow: hidden;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.15); /* More prominent inner shadow */
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--primary-color);
            border-radius: 8px;
            transition: width 0.9s linear;
        }

        /* Session info text */
        #timerScreen .session-info {
            font-size: 1.2rem;
            color: var(--on-surface);
            text-align: center;
            margin-top: 28px; /* More space */
        }

        #timerScreen .session-info span {
            display: block;
            margin-bottom: 10px; /* More space between lines */
            font-weight: 600;
        }

        /* Radio button and select styles */
        input[type="radio"] {
            margin-right: 10px; /* More space */
            transform: scale(1.2); /* Larger radio buttons */
            accent-color: var(--primary-color);
        }

        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke-width='1.5' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 8.25l-7.5 7.5-7.5-7.5' /%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 14px center; /* Adjust arrow position */
            background-size: 24px; /* Larger arrow */
            padding-right: 48px; /* Space for the arrow */
        }

        .material-icons {
            font-family: 'Material Icons';
            font-weight: normal;
            font-style: normal;
            font-size: 24px;
            display: inline-block;
            line-height: 1;
            text-transform: none;
            letter-spacing: normal;
            word-wrap: normal;
            white-space: nowrap;
            direction: ltr;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            -moz-osx-font-smoothing: grayscale;
            font-feature-settings: 'liga';
        }
    </style>
  </head>
  <body>
    <!-- Home Screen -->
    <div id="homeScreen" class="screen">
      <button id="homeScreenSettingsButton" class="icon-button top-right">
        <span class="material-icons">settings</span>
      </button>
      <div id="currentTimeDisplay" class="current-time"></div>
      <div class="home-buttons">
        <button id="focusButton" class="home-button">
          <span class="material-icons">self_improvement</span>集中する
        </button>
        <button id="viewRecordsButton" class="home-button">
          <span class="material-icons">bar_chart</span>記録を見る
        </button>
      </div>
    </div>

    <!-- Timer Screen -->
    <div id="timerScreen" class="screen hidden">
      <button id="backToHomeFromTimerButton" class="icon-button top-left">
        <span class="material-icons">arrow_back</span>
      </button>
      <h1 id="timerDisplay" class="timer-display">25:00</h1>
      <div class="progress-container">
        <div id="progressBarFill" class="progress-bar"></div>
      </div>
      <div class="button-group">
        <button id="startButton" class="button-primary">
          <span id="startButtonIcon" class="material-icons">play_arrow</span>
          <span id="startButtonText">スタート</span>
        </button>
        <button id="saveProgressButton" class="button-secondary hidden">
          <span class="material-icons">save</span>
          <span>保存</span>
        </button>
      </div>
      <div class="session-info">
        <span id="currentSessionWorkTime">集中: 0分</span>
        <span id="currentSessionBreakTime">休憩: 0分</span>
      </div>
      <button id="stopAlarmButton" class="button-secondary mt-6 hidden">
        <span class="material-icons">alarm_off</span>
        <span>アラームを停止</span>
      </button>
    </div>

    <!-- Records Screen -->
    <div id="recordsScreen" class="screen hidden">
      <div class="records-header">
        <button id="backToHomeFromRecordsButton" class="icon-button top-left">
          <span class="material-icons">arrow_back</span>
        </button>
        <h2>記録</h2>
      </div>
      <div class="records-time-unit-buttons">
        <button id="dailyViewButton" class="active">日単位</button>
        <button id="monthlyViewButton">月単位</button>
        <button id="yearlyViewButton">年単位</button>
      </div>
      <div class="chart-scroll-container">
        <canvas id="recordsChartCanvas"></canvas>
      </div>
      <p id="noDataMessage" class="text-gray-600 mt-4 hidden">まだ記録がありません。</p>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay hidden">
      <div class="modal-content">
        <h2 class="modal-header">設定</h2>
        <div class="modal-body">
          <label>作業時間:
            <input type="number" id="workTimeInput" min="5" value="25">分
          </label>
          <label>休憩時間:
            <input type="number" id="breakTimeInput" min="1" value="5">分
          </label>
          <label>テーマカラー:
            <input type="color" id="themeColorInput" value="#ef4444">
          </label>
          <label class="flex-col items-start mt-4">時計表示形式:
            <div class="flex items-center mt-2">
              <input type="radio" id="clockFormat24" name="clockFormat" value="24" class="mr-1">
              <span class="text-base">24時間</span>
              <input type="radio" id="clockFormat12" name="clockFormat" value="12" class="ml-6 mr-1">
              <span class="text-base">12時間</span>
            </div>
          </label>
          <label class="flex-col items-start mt-4">アラーム音:
            <div class="flex items-center mt-2 w-full">
              <select id="alarmSoundSelect" class="flex-grow mr-2 p-2 border border-gray-300 rounded-md"></select>
              <input type="file" id="alarmFileInput" accept="audio/mpeg, audio/wav, audio/ogg" class="hidden">
              <button id="addAlarmSoundButton" class="button-secondary p-2 !rounded-lg !shadow-none !text-base">
                <span class="material-icons !text-xl">add</span>
              </button>
              <button id="deleteAlarmSoundButton" class="bg-red-500 text-white p-2 ml-2 !rounded-lg hover:bg-red-600 transition-colors duration-200 !shadow-none !text-base">
                <span class="material-icons !text-xl">delete</span>
              </button>
            </div>
          </label>
        </div>
        <div class="modal-actions">
          <button class="button-cancel" id="cancelSettingsButton">キャンセル</button>
          <button class="button-save" id="saveSettingsButton">保存</button>
        </div>
      </div>
    </div>

    <audio id="alarmSound" src="https://pipocorp-japan.github.io/Pomodoro/alarm.mp3" preload="auto"></audio>

    <!-- Custom Alert/Confirm Dialog -->
    <div id="customAlertDialog" class="modal-overlay hidden">
      <div class="custom-alert-dialog">
        <p id="alertMessage"></p>
        <div class="modal-actions justify-center">
          <button class="button-cancel" id="alertCancelButton">いいえ</button>
          <button class="button-save" id="alertOkButton">はい</button>
        </div>
      </div>
    </div>

    <script>
    // --- DOM Elements ---
const homeScreen = document.getElementById('homeScreen');
const timerScreen = document.getElementById('timerScreen');
const recordsScreen = document.getElementById('recordsScreen');
const focusButton = document.getElementById('focusButton');
const viewRecordsButton = document.getElementById('viewRecordsButton');
const backToHomeFromTimerButton = document.getElementById('backToHomeFromTimerButton');
const backToHomeFromRecordsButton = document.getElementById('backToHomeFromRecordsButton');
const noDataMessage = document.getElementById('noDataMessage');
const homeScreenSettingsButton = document.getElementById('homeScreenSettingsButton');
const currentTimeDisplay = document.getElementById('currentTimeDisplay');

const timerDisplay = document.getElementById('timerDisplay');
const startButton = document.getElementById('startButton');
const startButtonIcon = document.getElementById('startButtonIcon');
const startButtonText = document.getElementById('startButtonText');
const saveProgressButton = document.getElementById('saveProgressButton');
const settingsModal = document.getElementById('settingsModal');
const workTimeInput = document.getElementById('workTimeInput');
const breakTimeInput = document.getElementById('breakTimeInput');
const themeColorInput = document.getElementById('themeColorInput');
const clockFormat24 = document.getElementById('clockFormat24');
const clockFormat12 = document.getElementById('clockFormat12');
const saveSettingsButton = document.getElementById('saveSettingsButton');
const cancelSettingsButton = document.getElementById('cancelSettingsButton');

// --- Alarm Sound Elements ---
const alarmSoundSelect = document.getElementById('alarmSoundSelect');
const alarmFileInput = document.getElementById('alarmFileInput');
const addAlarmSoundButton = document.getElementById('addAlarmSoundButton');
const deleteAlarmSoundButton = document.getElementById('deleteAlarmSoundButton');
const stopAlarmButton = document.getElementById('stopAlarmButton');

const customAlertDialog = document.getElementById('customAlertDialog');
const alertMessage = document.getElementById('alertMessage');
let alertOkButton = document.getElementById('alertOkButton');
let alertCancelButton = document.getElementById('alertCancelButton');

// Progress bar elements
const progressBarFill = document.getElementById('progressBarFill');

// Session time display elements
const currentSessionWorkTime = document.getElementById('currentSessionWorkTime');
const currentSessionBreakTime = document.getElementById('currentSessionBreakTime');

const recordsChartCanvas = document.getElementById('recordsChartCanvas');
let recordsChart; // To hold the Chart.js instance

// Records time unit buttons
const dailyViewButton = document.getElementById('dailyViewButton');
const monthlyViewButton = document.getElementById('monthlyViewButton');
const yearlyViewButton = document.getElementById('yearlyViewButton');

// --- Variables ---
let workTime = parseInt(localStorage.getItem('pomodoroWorkTime') || '25');
let breakTime = parseInt(localStorage.getItem('pomodoroBreakTime') || '5');
let themeColor = localStorage.getItem('pomodoroThemeColor') || '#ef4444';
let clockFormat = localStorage.getItem('pomodoroClockFormat') || '24'; // '24' or '12'
let currentTimeInSeconds = workTime * 60;
let totalPeriodSeconds = workTime * 60; // Total seconds for the current period
let isRunning = false;
let timerInterval = null; // Initialize to null
let isWorkPeriod = true; // true for work, false for break
let currentTimeInterval = null; // For home screen clock (global scope)

// Session accumulated times (reset on full cycle completion or manual save)
let sessionFocusedSeconds = 0;
let sessionBreakSeconds = 0;

const RECORDS_KEY = 'pomodoroRecords';
let currentChartTimeUnit = 'day'; // 'day', 'month', 'year'

// --- Audio ---
const alarmSound = document.getElementById('alarmSound'); // audio要素を取得
let audioUnlocked = false; // Add a flag to track if audio context is unlocked
let isAlarmPlaying = false; // Track if alarm is currently playing

// --- Alarm Sound Storage (IndexedDB) ---
const DB_NAME = 'pomodoro_db';
const STORE_NAME = 'alarm_sounds';
let db;

async function openIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
        };

        request.onerror = (event) => {
            console.error("IndexedDB error:", event.target.errorCode);
            reject(event.target.errorCode);
        };
    });
}

async function saveAlarmSound(name, dataUrl) {
    if (!db) await openIndexedDB(); // Ensure DB is open
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.add({ name: name, data: dataUrl });

        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
    });
}

async function deleteAlarmSound(id) {
    if (!db) await openIndexedDB(); // Ensure DB is open
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(id);

        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
    });
}

async function getAlarmSounds() {
    if (!db) await openIndexedDB(); // Ensure DB is open
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => resolve(request.result);
        request.onerror = (event) => reject(event.target.error);
    });
}

async function loadAlarmSoundsToSelect() {
    const sounds = await getAlarmSounds();
    alarmSoundSelect.innerHTML = ''; // Clear existing options

    // Default option
    const defaultOption = document.createElement('option');
    defaultOption.value = 'default';
    defaultOption.textContent = 'デフォルト';
    alarmSoundSelect.appendChild(defaultOption);

    sounds.forEach(sound => {
        const option = document.createElement('option');
        option.value = sound.id;
        option.textContent = sound.name;
        alarmSoundSelect.appendChild(option);
    });

    // Add "+" option at the bottom
    const addOption = document.createElement('option');
    addOption.value = 'add_new';
    addOption.textContent = '+ カスタム音を追加';
    alarmSoundSelect.appendChild(addOption);

    // Set selected value from localStorage or default
    const savedAlarmId = localStorage.getItem('pomodoroAlarmSoundId') || 'default';
    alarmSoundSelect.value = savedAlarmId;

    // Set the audio src immediately
    if (savedAlarmId === 'default') {
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
        deleteAlarmSoundButton.classList.add('hidden'); // Hide delete button for default
    } else if (savedAlarmId === 'add_new') {
        // If '+' was selected previously (shouldn't happen on load if logic is correct)
        // Revert to default or handle error. For now, revert to default.
        alarmSoundSelect.value = 'default';
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
        localStorage.setItem('pomodoroAlarmSoundId', 'default');
        deleteAlarmSoundButton.classList.add('hidden'); // Hide delete button for default
    } else {
        const selectedSound = sounds.find(s => s.id == savedAlarmId); // Use == for loose comparison as ID can be number/string
        if (selectedSound) {
            alarmSound.src = selectedSound.data;
            deleteAlarmSoundButton.classList.remove('hidden'); // Show delete button for custom
        } else {
            // If saved ID not found (e.g., sound deleted), revert to default
            alarmSoundSelect.value = 'default';
            alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
            localStorage.setItem('pomodoroAlarmSoundId', 'default');
            deleteAlarmSoundButton.classList.add('hidden'); // Hide delete button for default
        }
    }
}

function playAlarmSound() {
    // Stop any currently playing alarm to avoid overlaps
    alarmSound.pause();
    alarmSound.currentTime = 0;

    if (audioUnlocked) {
        alarmSound.volume = 0.5;
        alarmSound.play().then(() => {
            isAlarmPlaying = true;
            stopAlarmButton.classList.remove('hidden');
        }).catch(error => {
            console.warn("アラーム音の再生に失敗しました:", error);
            if (error.name === 'NotAllowedError' || error.name === 'AbortError') {
                showCustomAlertDialog('アラーム音の再生には、ページとのインタラクション（例: 開始ボタンのクリック）が必要です。', () => {}, () => {});
            } else if (error.name === 'NotSupportedError') {
                 showCustomAlertDialog('このアラーム音は再生できませんでした。別のファイルをお試しください。', () => {}, () => {});
            }
        });
    } else {
        console.log("Audio not unlocked yet. Waiting for user interaction.");
        // Try to unlock audio context silently on first user interaction
        alarmSound.volume = 0;
        alarmSound.play().then(() => {
            alarmSound.pause();
            alarmSound.currentTime = 0;
            alarmSound.volume = 0.5;
            audioUnlocked = true;
            console.log("Audio unlocked silently.");
            playAlarmSound(); // Now that it's unlocked, try playing the actual alarm sound again
        }).catch(error => {
            console.warn("Silent audio unlock failed:", error);
            // If silent unlock fails, we'll need a direct user interaction for audio.
            showCustomAlertDialog('アラーム音の再生には、ページとのインタラクションが必要です。', () => {}, () => {});
        });
    }
}

function stopAlarmSound() {
    if (isAlarmPlaying) {
        alarmSound.pause();
        alarmSound.currentTime = 0;
        isAlarmPlaying = false;
        stopAlarmButton.classList.add('hidden');
    }
}

// Function to unlock audio on first user interaction
function unlockAudio() {
    if (!audioUnlocked) {
        // Attempt to play a silent sound to unlock the audio context
        alarmSound.volume = 0;
        alarmSound.play().then(() => {
            alarmSound.pause();
            alarmSound.currentTime = 0;
            alarmSound.volume = 0.5;
            audioUnlocked = true;
            console.log("Audio unlocked by user interaction.");
        }).catch(error => {
            console.warn("Failed to unlock audio with user interaction:", error);
        });
    }
}

// --- Utility Functions ---
function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
}

function formatCurrentTime(date) {
    let hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    let ampm = '';

    if (clockFormat === '12') {
        ampm = hours >= 12 ? ' PM' : ' AM';
        hours = hours % 12;
        hours = hours ? hours : 12; // The hour '0' should be '12' in 12-hour format
    }

    // Pad hours only if 24-hour format or if 12-hour and hour is single digit (e.g., 09:00 AM)
    const formattedHours = (clockFormat === '24' || hours >= 10 || hours === 0) ? String(hours).padStart(2, '0') : String(hours);

    return `${formattedHours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}${ampm}`;
}

function updateCurrentTimeDisplay() {
    const now = new Date();
    currentTimeDisplay.textContent = formatCurrentTime(now);
}

function setThemeColors(color) {
    document.documentElement.style.setProperty('--primary-color', color);
    // Calculate a slightly darker shade for hover effect
    const hexToRgb = (hex) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    };

    const rgbToHex = (r, g, b) => {
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    };

    const { r, g, b } = hexToRgb(color);
    const darkerColor = rgbToHex(
        Math.max(0, r - 30),
        Math.max(0, g - 30),
        Math.max(0, b - 30)
    );
    document.documentElement.style.setProperty('--primary-color-dark', darkerColor);
    document.documentElement.style.setProperty('--primary-color-rgb', `${r}, ${g}, ${b}`);


    // Update chart colors immediately if chart exists
    if (recordsChart) {
        const primaryColorCss = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
        const breakColorCss = getComputedStyle(document.documentElement).getPropertyValue('--secondary-period-color').trim();
        recordsChart.data.datasets[0].backgroundColor = primaryColorCss;
        recordsChart.data.datasets[1].backgroundColor = breakColorCss;
        recordsChart.update();
    }
}

function updateDisplay() {
    timerDisplay.textContent = formatTime(currentTimeInSeconds);

    totalPeriodSeconds = isWorkPeriod ? workTime * 60 : breakTime * 60;

    const progressPercentage = totalPeriodSeconds > 0 ? ((totalPeriodSeconds - currentTimeInSeconds) / totalPeriodSeconds) * 100 : 0;
    progressBarFill.style.width = `${progressPercentage}%`;
    progressBarFill.style.backgroundColor = isWorkPeriod ? 'var(--primary-color)' : 'var(--secondary-period-color)';

    timerDisplay.style.color = isWorkPeriod ? 'var(--primary-color)' : 'var(--secondary-period-color)';

    updateTimerButtonVisibility();

    let displayWorkMins = Math.floor(sessionFocusedSeconds / 60);
    let displayBreakMins = Math.floor(sessionBreakSeconds / 60);

    currentSessionWorkTime.textContent = `集中: ${displayWorkMins}分`;
    currentSessionBreakTime.textContent = `休憩: ${displayBreakMins}分`;
}

function updateTimer() {
    if (!isRunning) return;

    currentTimeInSeconds--;
    if (isWorkPeriod) {
        sessionFocusedSeconds++;
    } else {
        sessionBreakSeconds++;
    }

    updateDisplay();

    if (currentTimeInSeconds <= 0) {
        clearInterval(timerInterval);
        playAlarmSound(); // Play alarm when timer ends

        if (isWorkPeriod) {
            // Work period ended, start break
            showCustomAlertDialog(
                '集中時間終了！休憩に入りますか？\n（「はい」で休憩開始、「いいえ」で集中時間を保存しホームに戻ります）',
                () => {
                    isWorkPeriod = false;
                    currentTimeInSeconds = breakTime * 60;
                    totalPeriodSeconds = breakTime * 60;
                    startButtonText.textContent = '休憩開始';
                    startButtonIcon.textContent = 'play_arrow'; // Material Icon
                    startButton.classList.remove('hidden');
                    saveProgressButton.classList.add('hidden');
                    startButton.click(); // Automatically start break
                },
                () => {
                    saveRecord();
                    resetTimer();
                    showScreen('home');
                }
            );
        } else {
            // Break period ended, suggest new work period
            showCustomAlertDialog(
                '休憩時間終了！新しい集中を始めますか？\n（「はい」で集中開始、「いいえ」で休憩時間を保存しホームに戻ります）',
                () => {
                    isWorkPeriod = true;
                    currentTimeInSeconds = workTime * 60;
                    totalPeriodSeconds = workTime * 60;
                    startButtonText.textContent = 'スタート';
                    startButtonIcon.textContent = 'play_arrow'; // Material Icon
                    startButton.classList.remove('hidden');
                    saveProgressButton.classList.add('hidden');
                    startButton.click(); // Automatically start new work period
                },
                () => {
                    saveRecord(); // Save accumulated break time
                    resetTimer();
                    showScreen('home');
                }
            );
        }
    }
}

function startTimer() {
    unlockAudio(); // Attempt to unlock audio on start
    if (!isRunning) {
        isRunning = true;
        timerInterval = setInterval(updateTimer, 1000);
        startButtonText.textContent = '一時停止';
        startButtonIcon.textContent = 'pause'; // Material Icon
        saveProgressButton.classList.remove('hidden'); // Show save button when running
    } else {
        pauseTimer();
    }
}

function pauseTimer() {
    isRunning = false;
    clearInterval(timerInterval);
    startButtonText.textContent = '再開';
    startButtonIcon.textContent = 'play_arrow'; // Material Icon
}

function resetTimer() {
    pauseTimer();
    currentTimeInSeconds = workTime * 60;
    isWorkPeriod = true;
    sessionFocusedSeconds = 0; // Reset session times
    sessionBreakSeconds = 0;   // Reset session times
    updateDisplay();
    startButtonText.textContent = 'スタート';
    startButtonIcon.textContent = 'play_arrow'; // Material Icon
    saveProgressButton.classList.add('hidden'); // Hide save button
    stopAlarmSound(); // Ensure alarm is stopped
}

function updateTimerButtonVisibility() {
    if (isRunning) {
        startButton.classList.remove('hidden');
        saveProgressButton.classList.remove('hidden');
    } else {
        // If paused or reset, only show start button if time is not zero
        if (currentTimeInSeconds > 0) {
            startButton.classList.remove('hidden');
            saveProgressButton.classList.remove('hidden'); // Still show save if paused with progress
        } else {
            startButton.classList.remove('hidden'); // Always show start button if timer is at 00:00 (for new cycle)
            saveProgressButton.classList.add('hidden'); // Hide save if timer is at 00:00 and not started
        }
    }
}

function saveRecord() {
    if (sessionFocusedSeconds === 0 && sessionBreakSeconds === 0) {
        console.log("No time to record for this session.");
        return;
    }

    const records = JSON.parse(localStorage.getItem(RECORDS_KEY) || '[]');
    const now = new Date();
    const dateString = now.toISOString().split('T')[0]; // YYYY-MM-DD

    let recordFound = false;
    for (let i = 0; i < records.length; i++) {
        if (records[i].date === dateString) {
            records[i].focusedMinutes = (records[i].focusedMinutes || 0) + Math.floor(sessionFocusedSeconds / 60);
            records[i].breakMinutes = (records[i].breakMinutes || 0) + Math.floor(sessionBreakSeconds / 60);
            recordFound = true;
            break;
        }
    }

    if (!recordFound) {
        records.push({
            date: dateString,
            focusedMinutes: Math.floor(sessionFocusedSeconds / 60),
            breakMinutes: Math.floor(sessionBreakSeconds / 60)
        });
    }

    localStorage.setItem(RECORDS_KEY, JSON.stringify(records));
    sessionFocusedSeconds = 0; // Reset after saving
    sessionBreakSeconds = 0;   // Reset after saving
    updateDisplay(); // Update session info display
    console.log("Record saved:", records);
}

function showCustomAlertDialog(message, onOk, onCancel) {
    alertMessage.textContent = message;
    customAlertDialog.classList.remove('hidden');
    customAlertDialog.classList.add('visible');

    const handleOk = () => {
        onOk();
        customAlertDialog.classList.remove('visible');
        // Use a timeout to apply 'hidden' after transition
        setTimeout(() => {
            customAlertDialog.classList.add('hidden');
        }, 300); // Match CSS transition duration
        alertOkButton.removeEventListener('click', handleOk);
        alertCancelButton.removeEventListener('click', handleCancel);
    };

    const handleCancel = () => {
        if (onCancel) onCancel();
        customAlertDialog.classList.remove('visible');
        setTimeout(() => {
            customAlertDialog.classList.add('hidden');
        }, 300);
        alertOkButton.removeEventListener('click', handleOk);
        alertCancelButton.removeEventListener('click', handleCancel);
    };

    alertOkButton.addEventListener('click', handleOk);
    alertCancelButton.addEventListener('click', handleCancel);
}

// --- Screen Management ---
function showScreen(screenId) {
    const screens = [homeScreen, timerScreen, recordsScreen];
    screens.forEach(screen => {
        if (screen.id === screenId + 'Screen') {
            screen.classList.remove('hidden');
            // Trigger reflow to ensure transition plays
            void screen.offsetWidth;
            screen.classList.add('visible');
        } else {
            screen.classList.remove('visible');
            // Use a timeout to apply 'hidden' after transition
            setTimeout(() => {
                screen.classList.add('hidden');
            }, 400); // Match CSS transition duration
        }
    });

    if (screenId === 'home') {
        currentTimeInterval = setInterval(updateCurrentTimeDisplay, 1000);
    } else {
        if (currentTimeInterval) {
            clearInterval(currentTimeInterval);
            currentTimeInterval = null;
        }
    }
    if (screenId === 'records') {
        renderRecordsChart(currentChartTimeUnit);
    }
}

// --- Event Listeners ---
focusButton.addEventListener('click', () => {
    showScreen('timer');
    resetTimer(); // Ensure timer is reset when entering focus mode
    updateDisplay(); // Initialize display
});

viewRecordsButton.addEventListener('click', () => {
    showScreen('records');
    renderRecordsChart(currentChartTimeUnit);
});

backToHomeFromTimerButton.addEventListener('click', () => {
    if (isRunning || sessionFocusedSeconds > 0 || sessionBreakSeconds > 0) {
        showCustomAlertDialog(
            'タイマーを中断してホームに戻りますか？\n現在の集中/休憩時間は保存されません。',
            () => {
                resetTimer();
                stopAlarmSound();
                showScreen('home');
            },
            () => {
                // Do nothing, stay on timer screen
            }
        );
    } else {
        showScreen('home');
        resetTimer(); // Reset only if no time was accumulated or running
        stopAlarmSound();
    }
});

backToHomeFromRecordsButton.addEventListener('click', () => {
    showScreen('home');
});

startButton.addEventListener('click', startTimer);
saveProgressButton.addEventListener('click', () => {
    saveRecord();
    resetTimer();
    showScreen('home');
});

homeScreenSettingsButton.addEventListener('click', () => {
    // Populate settings modal with current values
    workTimeInput.value = workTime;
    breakTimeInput.value = breakTime;
    themeColorInput.value = themeColor;
    if (clockFormat === '24') {
        clockFormat24.checked = true;
    } else {
        clockFormat12.checked = true;
    }
    loadAlarmSoundsToSelect(); // Load custom sounds
    settingsModal.classList.remove('hidden');
    settingsModal.classList.add('visible');
});

cancelSettingsButton.addEventListener('click', () => {
    settingsModal.classList.remove('visible');
    setTimeout(() => {
        settingsModal.classList.add('hidden');
    }, 300);
});

saveSettingsButton.addEventListener('click', () => {
    workTime = parseInt(workTimeInput.value);
    breakTime = parseInt(breakTimeInput.value);
    themeColor = themeColorInput.value;
    clockFormat = clockFormat24.checked ? '24' : '12';

    localStorage.setItem('pomodoroWorkTime', workTime);
    localStorage.setItem('pomodoroBreakTime', breakTime);
    localStorage.setItem('pomodoroThemeColor', themeColor);
    localStorage.setItem('pomodoroClockFormat', clockFormat);
    localStorage.setItem('pomodoroAlarmSoundId', alarmSoundSelect.value); // Save selected alarm sound ID

    setThemeColors(themeColor); // Apply theme immediately
    resetTimer(); // Reset timer to apply new work/break times
    console.log("設定が保存されました。新しい作業時間:", workTime, "リセット後の現在の時間:", currentTimeInSeconds); // Debugging line
    updateDisplay(); // Update display with new times
    updateCurrentTimeDisplay(); // Update home screen clock format

    // Set actual alarm sound src based on selection
    if (alarmSoundSelect.value === 'default') {
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
    } else {
        getAlarmSounds().then(sounds => {
            const selectedSound = sounds.find(s => s.id == alarmSoundSelect.value);
            if (selectedSound) {
                alarmSound.src = selectedSound.data;
            } else {
                // Fallback if selected custom sound is no longer available
                alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                localStorage.setItem('pomodoroAlarmSoundId', 'default');
                alarmSoundSelect.value = 'default';
            }
        });
    }

    settingsModal.classList.remove('visible');
    setTimeout(() => {
        settingsModal.classList.add('hidden');
    }, 300);
});

// Alarm sound selection change handler
alarmSoundSelect.addEventListener('change', async (event) => {
    const selectedValue = event.target.value;
    if (selectedValue === 'add_new') {
        alarmFileInput.click(); // Trigger file input
        alarmSoundSelect.value = localStorage.getItem('pomodoroAlarmSoundId') || 'default'; // Revert selection
    } else if (selectedValue === 'default') {
        deleteAlarmSoundButton.classList.add('hidden');
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
    } else {
        deleteAlarmSoundButton.classList.remove('hidden');
        const sounds = await getAlarmSounds();
        const selectedSound = sounds.find(s => s.id == selectedValue);
        if (selectedSound) {
            alarmSound.src = selectedSound.data;
        }
    }
});

// Handling file input for custom alarm sounds
alarmFileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        if (!file.type.startsWith('audio/')) {
            showCustomAlertDialog('音声ファイルを選択してください。', () => {}, () => {});
            return;
        }

        const reader = new FileReader();
        reader.onload = async (e) => {
            const dataUrl = e.target.result;
            const soundName = file.name.split('.').slice(0, -1).join('.'); // Get name without extension
            try {
                await saveAlarmSound(soundName, dataUrl);
                await loadAlarmSoundsToSelect(); // Reload options including new sound
                // Attempt to select the newly added sound by finding its ID
                const newlyAddedSound = (await getAlarmSounds()).find(s => s.name === soundName && s.data === dataUrl);
                if (newlyAddedSound) {
                    alarmSoundSelect.value = newlyAddedSound.id;
                    localStorage.setItem('pomodoroAlarmSoundId', newlyAddedSound.id);
                    alarmSound.src = dataUrl; // Set alarm audio source
                    deleteAlarmSoundButton.classList.remove('hidden'); // Show delete button
                } else {
                    // Fallback if for some reason the sound couldn't be found after saving
                    console.warn("Newly added sound not found in select list, reverting to default.");
                    alarmSoundSelect.value = 'default';
                    alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                    localStorage.setItem('pomodoroAlarmSoundId', 'default');
                    deleteAlarmSoundButton.classList.add('hidden');
                }
            } catch (error) {
                console.error("Failed to save or load alarm sound:", error);
                showCustomAlertDialog('アラーム音の保存に失敗しました。', () => {}, () => {});
            }
        };
        reader.readAsDataURL(file);
    }
});

deleteAlarmSoundButton.addEventListener('click', async () => {
    const selectedId = alarmSoundSelect.value;
    if (selectedId !== 'default') {
        showCustomAlertDialog('選択したアラーム音を削除しますか？', async () => {
            try {
                await deleteAlarmSound(parseInt(selectedId));
                await loadAlarmSoundsToSelect();
                // If the deleted sound was currently selected, revert to default
                if (localStorage.getItem('pomodoroAlarmSoundId') == selectedId) { // Use == for comparison
                    localStorage.setItem('pomodoroAlarmSoundId', 'default');
                }
                alarmSoundSelect.value = localStorage.getItem('pomodoroAlarmSoundId') || 'default';
                // Re-evaluate the src and delete button visibility based on the new selection
                if (alarmSoundSelect.value === 'default') {
                    alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                    deleteAlarmSoundButton.classList.add('hidden');
                } else {
                    const sounds = await getAlarmSounds();
                    const selectedSound = sounds.find(s => s.id == alarmSoundSelect.value);
                    if (selectedSound) {
                        alarmSound.src = selectedSound.data;
                        deleteAlarmSoundButton.classList.remove('hidden');
                    } else {
                        // Fallback if the new selected ID is also somehow invalid
                        alarmSoundSelect.value = 'default';
                        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                        localStorage.setItem('pomodoroAlarmSoundId', 'default');
                        deleteAlarmSoundButton.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error("Failed to delete alarm sound:", error);
                showCustomAlertDialog('アラーム音の削除に失敗しました。', () => {}, () => {});
            }
        }, () => {});
    }
});

stopAlarmButton.addEventListener('click', stopAlarmSound);

// --- Chart.js for Records ---
function renderRecordsChart(timeUnit) {
    const records = JSON.parse(localStorage.getItem(RECORDS_KEY) || '[]');
    if (records.length === 0) {
        noDataMessage.classList.remove('hidden');
        if (recordsChart) {
            recordsChart.destroy(); // Destroy existing chart if no data
            recordsChart = null;
        }
        recordsChartCanvas.classList.add('hidden'); // Hide canvas if no data
        return;
    } else {
        noDataMessage.classList.add('hidden');
        recordsChartCanvas.classList.remove('hidden');
    }

    const processedData = processRecordsForChart(records, timeUnit);
    const labels = processedData.map(d => d.label);
    const focusedData = processedData.map(d => d.focused);
    const breakData = processedData.map(d => d.break);

    if (recordsChart) {
        recordsChart.destroy(); // Destroy existing chart before creating a new one
    }

    recordsChart = new Chart(recordsChartCanvas, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: '集中時間 (分)',
                    data: focusedData,
                    backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(),
                    borderRadius: 6 // More rounded bars
                },
                {
                    label: '休憩時間 (分)',
                    data: breakData,
                    backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--secondary-period-color').trim(),
                    borderRadius: 6 // More rounded bars
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y + '分';
                            }
                            return label;
                        }
                    },
                    bodyFont: {
                        family: 'Inter, sans-serif',
                        size: 14
                    },
                    titleFont: {
                        family: 'Inter, sans-serif',
                        size: 16,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        font: {
                            size: 15,
                            family: 'Inter, sans-serif',
                            weight: '500'
                        },
                        color: 'var(--on-surface)'
                    }
                },
                title: {
                    display: true,
                    text: getChartTitle(timeUnit),
                    font: {
                        size: 20,
                        family: 'Inter, sans-serif',
                        weight: '700'
                    },
                    color: 'var(--on-surface)'
                }
            },
            scales: {
                x: {
                    stacked: true,
                    grid: {
                        display: false
                    },
                    ticks: {
                        font: {
                            family: 'Inter, sans-serif',
                            size: 13
                        },
                        color: 'var(--on-surface)'
                    },
                    title: {
                        display: true,
                        text: getXAxisTitle(timeUnit),
                        font: {
                            family: 'Inter, sans-serif',
                            weight: '600',
                            size: 14
                        },
                        color: 'var(--on-surface)'
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return value + '分';
                        },
                        font: {
                            family: 'Inter, sans-serif',
                            size: 13
                        },
                        color: 'var(--on-surface)'
                    },
                    grid: {
                        color: '#e0e0e0'
                    },
                    title: {
                        display: true,
                        text: '時間 (分)',
                        font: {
                            family: 'Inter, sans-serif',
                            weight: '600',
                            size: 14
                        },
                        color: 'var(--on-surface)'
                    }
                }
            }
        }
    });

    // Adjust chart canvas width for daily view if many days
    if (timeUnit === 'day' && labels.length > 7) {
        recordsChartCanvas.style.minWidth = `${labels.length * 65}px`; // Approx 65px per bar for better spacing
    } else {
        recordsChartCanvas.style.minWidth = 'unset';
    }
}

function processRecordsForChart(records, timeUnit) {
    const dataMap = new Map();

    records.forEach(record => {
        const date = new Date(record.date);
        let key;
        let label;

        if (timeUnit === 'day') {
            key = record.date; // YYYY-MM-DD
            label = `${date.getMonth() + 1}/${date.getDate()}`; // M/D
        } else if (timeUnit === 'month') {
            key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`; // YYYY-MM
            label = `${date.getMonth() + 1}月`;
        } else if (timeUnit === 'year') {
            key = String(date.getFullYear()); // YYYY
            label = `${date.getFullYear()}年`;
        }

        if (!dataMap.has(key)) {
            dataMap.set(key, { focused: 0, break: 0, label: label, date: date });
        }
        const entry = dataMap.get(key);
        entry.focused += record.focusedMinutes;
        entry.break += record.breakMinutes;
    });

    // Convert map values to array and sort by date
    const sortedData = Array.from(dataMap.values()).sort((a, b) => a.date.getTime() - b.date.getTime());

    // Fill in missing dates/months/years for better chart representation
    const filledData = [];
    if (sortedData.length > 0) {
        let currentDate = new Date(sortedData[0].date);
        const endDate = new Date(sortedData[sortedData.length - 1].date);

        while (currentDate <= endDate) {
            let key;
            let label;
            let foundEntry = null;

            if (timeUnit === 'day') {
                key = currentDate.toISOString().split('T')[0];
                label = `${currentDate.getMonth() + 1}/${currentDate.getDate()}`;
                foundEntry = sortedData.find(d => d.label === label && d.date.getFullYear() === currentDate.getFullYear() && new Date(d.date).getMonth() === currentDate.getMonth());
                currentDate.setDate(currentDate.getDate() + 1);
            } else if (timeUnit === 'month') {
                key = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
                label = `${currentDate.getMonth() + 1}月`;
                foundEntry = sortedData.find(d => d.label === label && d.date.getFullYear() === currentDate.getFullYear());
                currentDate.setMonth(currentDate.getMonth() + 1);
            } else if (timeUnit === 'year') {
                key = String(currentDate.getFullYear());
                label = `${currentDate.getFullYear()}年`;
                foundEntry = sortedData.find(d => d.label === label);
                currentDate.setFullYear(currentDate.getFullYear() + 1);
            }

            if (foundEntry) {
                filledData.push(foundEntry);
            } else {
                filledData.push({ focused: 0, break: 0, label: label, date: new Date(currentDate) }); // Use a copy of currentDate
            }
        }
    }

    return filledData;
}

function getChartTitle(timeUnit) {
    switch (timeUnit) {
        case 'day': return '日別集中・休憩時間';
        case 'month': return '月別集中・休憩時間';
        case 'year': return '年別集中・休憩時間';
        default: return '集中・休憩時間の記録';
    }
}

function getXAxisTitle(timeUnit) {
    switch (timeUnit) {
        case 'day': return '日付';
        case 'month': return '月';
        case 'year': return '年';
        default: return '単位';
    }
}

dailyViewButton.addEventListener('click', () => {
    currentChartTimeUnit = 'day';
    dailyViewButton.classList.add('active');
    monthlyViewButton.classList.remove('active');
    yearlyViewButton.classList.remove('active');
    renderRecordsChart(currentChartTimeUnit);
});

monthlyViewButton.addEventListener('click', () => {
    currentChartTimeUnit = 'month';
    monthlyViewButton.classList.add('active');
    dailyViewButton.classList.remove('active');
    yearlyViewButton.classList.remove('active');
    renderRecordsChart(currentChartTimeUnit);
});

yearlyViewButton.addEventListener('click', () => {
    currentChartTimeUnit = 'year';
    yearlyViewButton.classList.add('active');
    dailyViewButton.classList.remove('active');
    monthlyViewButton.classList.remove('active');
    renderRecordsChart(currentChartTimeUnit);
});


// --- Initial Setup ---
document.addEventListener('DOMContentLoaded', async () => {
    // Apply saved theme color
    setThemeColors(themeColor);

    // Set initial clock format for home screen
    if (clockFormat === '24') {
        clockFormat24.checked = true;
    } else {
        clockFormat12.checked = true;
    }

    // Initialize display with current work time
    updateDisplay();

    // Show home screen initially and start updating clock
    showScreen('home');

    // Load custom alarm sounds
    await openIndexedDB(); // Open DB when DOM is ready
    await loadAlarmSoundsToSelect();

    // Add a global click listener to unlock audio for browsers
    // that require user interaction for audio playback.
    document.body.addEventListener('click', unlockAudio, { once: true });
});

    </script>
  </body>
</html>
