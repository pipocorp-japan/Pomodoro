<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ポモドーロタイマー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        /* Define CSS Custom Properties for theme colors */
        :root {
            /* Light Mode Defaults */
            --primary-color-light: #ef4444;
            --primary-color-dark-light: #dc2626;
            --secondary-period-color-light: #10b981;
            --on-primary-light: #ffffff;
            --on-surface-light: #1f2937;
            --surface-color-light: #ffffff;
            --background-color-light: #f0f2f5;
            --text-light-light: #6b7280;
            --outline-color-light: #d1d5db;
            --grid-color-light: #e0e0e0;
            --analog-hand-color-light: #1f2937; /* Dark text for hands */

            /* Dark Mode specific colors */
            --primary-color-dark-mode: #f87171; /* Slightly lighter red for dark mode */
            --primary-color-darker-dark-mode: #ef4444; /* Darker red for hover */
            --secondary-period-color-dark-mode: #34d399; /* Lighter green for dark mode */
            --on-primary-dark-mode: #1f2937; /* Dark text on light accent */
            --on-surface-dark-mode: #e0e0e0; /* Light text on dark surface */
            --surface-color-dark-mode: #2d3748; /* Dark surface */
            --background-color-dark-mode: #1a202c; /* Dark background */
            --text-light-dark-mode: #a0aec0; /* Lighter text for dark mode */
            --outline-color-dark-mode: #4a5568; /* Darker outline for inputs */
            --grid-color-dark-mode: #4a5568; /* Darker grid lines for dark mode */
            --analog-hand-color-dark-mode: #e0e0e0; /* Light text for hands */


            /* Active theme variables (these will be set by JS or system preference) */
            --primary-color: var(--primary-color-light);
            --primary-color-dark: var(--primary-color-dark-light);
            --secondary-period-color: var(--secondary-period-color-light);
            --on-primary: var(--on-primary-light);
            --on-surface: var(--on-surface-light);
            --background-color: var(--background-color-light);
            --text-light: var(--text-light-light);
            --outline-color: var(--outline-color-light);
            --grid-color: var(--grid-color-light);
            --analog-hand-color: var(--analog-hand-color-light);
            --surface-color: var(--surface-color-light); /* Moved here to be set by theme */
        }

        /* Dark mode class to override active theme variables */
        body.dark-mode {
            --primary-color: var(--primary-color-dark-mode);
            --primary-color-dark: var(--primary-color-darker-dark-mode);
            --secondary-period-color: var(--secondary-period-color-dark-mode);
            --on-primary: var(--on-primary-dark-mode);
            --on-surface: var(--on-surface-dark-mode);
            --surface-color: var(--surface-color-dark-mode);
            --background-color: var(--background-color-dark-mode);
            --text-light: var(--text-light-dark-mode);
            --outline-color: var(--outline-color-dark-mode);
            --grid-color: var(--grid-color-dark-mode);
            --analog-hand-color: var(--analog-hand-color-dark-mode);
        }

        /* Light mode class (explicitly sets light theme) */
        body.light-mode {
            --primary-color: var(--primary-color-light);
            --primary-color-dark: var(--primary-color-dark-light);
            --secondary-period-color: var(--secondary-period-color-light);
            --on-primary: var(--on-primary-light);
            --on-surface: var(--on-surface-light);
            --surface-color: var(--surface-color-light);
            --background-color: var(--background-color-light);
            --text-light: var(--text-light-light);
            --outline-color: var(--outline-color-light);
            --grid-color: var(--grid-color-light);
            --analog-hand-color: var(--analog-hand-color-light);
        }

        /* System dark mode preference (applies only if no explicit class is set) */
        @media (prefers-color-scheme: dark) {
            body:not(.light-mode):not(.dark-mode) {
                --primary-color: var(--primary-color-dark-mode);
                --primary-color-dark: var(--primary-color-darker-dark-mode);
                --secondary-period-color: var(--secondary-period-color-dark-mode);
                --on-primary: var(--on-primary-dark-mode);
                --on-surface: var(--on-surface-dark-mode);
                --surface-color: var(--surface-color-dark-mode);
                --background-color: var(--background-color-dark-mode);
                --text-light: var(--text-light-dark-mode);
                --outline-color: var(--outline-color-dark-mode);
                --grid-color: var(--grid-color-dark-mode);
                --analog-hand-color: var(--analog-hand-color-dark-mode);
            }
        }

        /* General Body and Screen Layout */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 24px;
            box-sizing: border-box;
            overflow-x: hidden;
            color: var(--on-surface);
            line-height: 1.5; /* Improved readability */
            transition: background-color 0.3s ease-in-out; /* Smooth background transition */
        }

        .screen {
            background-color: var(--surface-color);
            border-radius: 28px; /* Significantly more rounded corners for Material You */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1); /* Stronger, layered shadow */
            padding: 36px; /* More generous padding */
            width: 100%;
            max-width: 480px; /* Wider max-width for modern feel */
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            min-height: 520px; /* Ensure consistent card size */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Material-like easing */
        }

        .screen.hidden {
            display: none !important;
            opacity: 0;
            transform: translateY(30px); /* Larger offset for animation */
        }
        .screen.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Timer Screen specific styles */
        #timerScreen .timer-display {
            font-size: 8rem; /* Even larger timer font */
            font-weight: 800; /* Extra bold for timer */
            color: var(--primary-color);
            margin-bottom: 32px; /* More space */
            letter-spacing: -4px; /* More pronounced letter spacing */
            line-height: 1; /* Prevent extra space above/below */
            transition: color 0.3s ease-in-out; /* Smooth color transition */
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px; /* More space between buttons */
            margin-top: 32px;
        }

        .button-primary {
            background-color: var(--primary-color);
            color: var(--on-primary);
            padding: 20px 40px; /* Larger padding */
            border-radius: 40px; /* Very rounded, FAB-like */
            font-size: 1.8rem; /* Larger font */
            font-weight: 700; /* Bolder weight */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 3px 6px rgba(0, 0, 0, 0.12); /* Stronger, layered shadow */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            white-space: nowrap;
        }

        .button-primary:hover {
            background-color: var(--primary-color-dark);
            transform: translateY(-4px); /* More pronounced lift */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25), 0 4px 8px rgba(0, 0, 0, 0.15); /* Stronger shadow on hover */
        }

        .button-primary:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button-secondary {
            background-color: #e8eaf6; /* Light indigo background */
            color: #3f51b5; /* Indigo text color */
            padding: 18px 32px;
            border-radius: 36px;
            font-size: 1.6rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1); /* Slightly stronger shadow */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            white-space: nowrap;
        }
        body.dark-mode .button-secondary { /* Dark mode specific secondary button color */
            background-color: #4a5568;
            color: #a0aec0;
        }


        .button-secondary:hover {
            background-color: #c5cae9; /* Darker indigo on hover */
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
        }
        body.dark-mode .button-secondary:hover {
            background-color: #6a7486;
        }

        .button-secondary:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .icon-button {
            background-color: transparent;
            border: none;
            font-size: 2.8rem; /* Larger icons */
            color: var(--text-light);
            cursor: pointer;
            transition: color 0.3s ease, background-color 0.3s ease;
            outline: none;
            border-radius: 50%;
            padding: 12px; /* Larger tap area */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-button:hover {
            color: var(--on-surface);
            background-color: rgba(0, 0, 0, 0.06); /* More visible hover effect */
        }

        .icon-button.top-right {
            position: absolute;
            top: 24px; /* More space from edge */
            right: 24px;
        }

        .icon-button.top-left {
            position: absolute;
            top: 24px;
            left: 24px;
            font-size: 2.4rem; /* Slightly smaller for back button */
        }

        /* Modal / Dialog Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Darker overlay for focus */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }

        .modal-overlay.visible {
            opacity: 1;
        }

        .modal-content {
            background-color: var(--surface-color);
            padding: 32px;
            border-radius: 20px; /* Consistent rounded corners */
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 6px 12px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 500px; /* Wider modal */
            transform: translateY(30px);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
            display: flex; /* Flex container for scrollable content */
            flex-direction: column;
            max-height: 90vh; /* Limit height to prevent overflow on small screens */
        }

        .modal-overlay.visible .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-header {
            font-size: 2rem; /* Larger header */
            font-weight: 700;
            margin-bottom: 28px; /* More space */
            color: var(--on-surface);
            transition: color 0.3s ease-in-out;
        }

        .modal-body {
            flex-grow: 1; /* Allow body to grow and take available space */
            overflow-y: auto; /* Enable scrolling for modal content */
            padding-right: 10px; /* Space for scrollbar */
            margin-right: -10px; /* Compensate for padding */
        }
        .modal-body label {
            display: flex;
            align-items: center;
            margin-bottom: 20px; /* More space between labels */
            font-size: 1.2rem; /* Larger font */
            color: var(--on-surface);
            font-weight: 500;
            transition: color 0.3s ease-in-out;
        }

        .modal-body input[type="number"],
        .modal-body input[type="color"],
        .modal-body select {
            flex-grow: 1;
            margin-left: 16px; /* More space */
            padding: 12px 16px; /* More padding */
            border: 1px solid var(--outline-color);
            border-radius: 12px; /* More rounded inputs */
            font-size: 1.1rem;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease-in-out, color 0.3s ease-in-out;
            background-color: #fcfcfc;
            color: var(--on-surface);
        }
        body.dark-mode .modal-body input[type="number"],
        body.dark-mode .modal-body input[type="color"],
        body.dark-mode .modal-body select {
            background-color: #1a202c; /* Darker input background */
            color: var(--on-surface);
        }

        .modal-body input[type="color"] {
            padding: 0;
            width: 70px; /* Adjust width for color picker */
            height: 50px; /* Adjust height for color picker */
            cursor: pointer;
        }

        .modal-body input[type="number"]:focus,
        .modal-body input[type="color"]:focus,
        .modal-body select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(var(--primary-color-rgb), 0.3); /* Stronger shadow */
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 16px; /* More space */
            margin-top: 32px;
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }

        .modal-actions button {
            padding: 12px 24px;
            border-radius: 12px; /* Rounded buttons in modal */
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease, box-shadow 0.2s ease, color 0.3s ease-in-out;
        }

        .modal-actions .button-cancel {
            background-color: #e0e0e0;
            color: var(--on-surface);
        }

        .modal-actions .button-cancel:hover {
            background-color: #d0d0d0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .modal-actions .button-save {
            background-color: var(--secondary-period-color);
            color: var(--on-primary);
        }

        .modal-actions .button-save:hover {
            background-color: #059669;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        /* Custom Alert Dialog */
        .custom-alert-dialog {
            background-color: var(--surface-color);
            padding: 32px;
            border-radius: 20px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25), 0 6px 12px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 450px;
            text-align: center;
            transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }

        .custom-alert-dialog p {
            font-size: 1.25rem; /* Larger message */
            margin-bottom: 32px;
            color: var(--on-surface);
            line-height: 1.6;
            font-weight: 500;
            transition: color 0.3s ease-in-out;
        }

        /* Home Screen specific styles */
        #homeScreen .current-time {
            font-size: clamp(2.5rem, 8vw, 4rem); /* Responsive font size */
            font-weight: 700;
            color: var(--on-surface);
            margin-top: 40px;
            margin-bottom: 60px; /* More space */
            transition: color 0.3s ease-in-out;
            font-variant-numeric: tabular-nums; /* Ensures numbers have consistent width */
            text-align: center; /* Center text within its div */
            width: 100%; /* Ensure it takes full width of its container */
            padding: 0 10px; /* Small horizontal padding to prevent touch edge of the card */
            box-sizing: border-box; /* Include padding in element's total width */
        }

        #homeScreen .home-clock-container {
            width: 100%;
            max-width: 280px; /* Maximum size */
            aspect-ratio: 1 / 1; /* Force square aspect ratio based on width */
            position: relative; /* For absolute positioning of canvas */
            margin-top: 40px;
            margin-bottom: 60px;
            display: flex; /* Keep flex for centering digital content */
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
            background-color: var(--surface-color);
            transition: background-color 0.3s ease-in-out;
            overflow: hidden; /* Ensure content doesn't spill */
        }
        #analogClockCanvas {
            position: absolute; /* Position absolutely within the square container */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block; /* Ensure no extra space below canvas */
        }


        #homeScreen .home-buttons {
            display: flex;
            flex-direction: column;
            gap: 28px; /* More space between buttons */
            width: 100%;
        }

        #homeScreen .home-button {
            background-color: var(--primary-color);
            color: var(--on-primary);
            padding: 24px; /* More padding */
            border-radius: 20px; /* Consistent rounded corners */
            font-size: 2rem; /* Larger font */
            font-weight: 600;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, color 0.3s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px; /* More space between icon and text */
        }

        #homeScreen .home-button .material-icons {
            font-size: 2.4rem; /* Icon size */
        }

        #homeScreen .home-button:hover {
            background-color: var(--primary-color-dark);
            transform: translateY(-4px);
            box-shadow: 0 7px 14px rgba(0, 0, 0, 0.2);
        }

        #homeScreen .home-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        /* Records Screen specific styles */
        #recordsScreen .records-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 28px;
        }

        #recordsScreen .records-header h2 {
            font-size: 2.2rem; /* Larger header */
            font-weight: 700;
            color: var(--on-surface);
            margin-left: auto;
            margin-right: auto;
            transition: color 0.3s ease-in-out;
        }

        #recordsScreen .records-time-unit-buttons {
            display: flex;
            justify-content: center;
            gap: 16px; /* More space */
            margin-top: 15px;
            margin-bottom: 28px;
            width: 100%;
        }

        #recordsScreen .records-time-unit-buttons button {
            background-color: #e0e0e0;
            color: var(--on-surface);
            padding: 12px 20px;
            border-radius: 12px; /* More rounded */
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            outline: none;
            transition: background-color 0.3s ease, box-shadow 0.2s ease, color 0.3s ease-in-out;
        }
        body.dark-mode #recordsScreen .records-time-unit-buttons button {
            background-color: #4a5568;
            color: #e0e0e0;
        }

        #recordsScreen .records-time-unit-buttons button.active {
            background-color: var(--primary-color);
            color: var(--on-primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        body.dark-mode #recordsScreen .records-time-unit-buttons button.active {
             background-color: var(--primary-color-dark-mode); /* Use dark mode primary for active */
             color: var(--on-primary-dark-mode);
        }
        #recordsScreen .records-time-unit-buttons button:hover:not(.active) {
            background-color: #d0d0d0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        body.dark-mode #recordsScreen .records-time-unit-buttons button:hover:not(.active) {
            background-color: #6a7486;
        }

        .chart-scroll-container {
            width: 100%;
            overflow-x: auto;
            max-width: 100%;
            padding-bottom: 15px;
        }
        #recordsChartCanvas {
            width: 100% !important;
            height: 350px !important; /* Taller chart */
            min-width: 450px; /* Minimum width to prevent excessive squeezing for daily view */
        }

        /* Progress Bar styles */
        .progress-container {
            width: 95%; /* Wider progress bar */
            height: 16px; /* Thicker progress bar */
            background-color: #e5e7eb;
            border-radius: 8px; /* Matches height for full roundness */
            margin-top: 28px;
            overflow: hidden;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.15); /* More prominent inner shadow */
            transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }
        body.dark-mode .progress-container {
            background-color: #4a5568; /* Darker progress track */
        }


        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--primary-color);
            border-radius: 8px;
            transition: width 0.9s linear, background-color 0.3s ease-in-out;
        }

        /* Session info text */
        #timerScreen .session-info {
            font-size: 1.2rem;
            color: var(--on-surface);
            text-align: center;
            margin-top: 28px; /* More space */
            transition: color 0.3s ease-in-out;
        }

        #timerScreen .session-info span {
            display: block;
            margin-bottom: 10px; /* More space between lines */
            font-weight: 600;
        }

        /* Radio button and select styles */
        input[type="radio"] {
            margin-right: 10px; /* More space */
            transform: scale(1.2); /* Larger radio buttons */
            accent-color: var(--primary-color);
            transition: accent-color 0.3s ease-in-out;
        }

        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke-width='1.5' stroke='currentColor'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M19.5 8.25l-7.5 7.5-7.5-7.5' /%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 14px center; /* Adjust arrow position */
            background-size: 24px; /* Larger arrow */
            padding-right: 48px; /* Space for the arrow */
        }
        /* Chart.js specific color updates for dark mode */
        body.dark-mode canvas {
            background-color: var(--surface-color); /* Chart background */
        }
        body.dark-mode .chartjs-render-monitor {
            color: var(--on-surface); /* Chart text color */
        }
    </style>
  </head>
  <body>
    <div id="homeScreen" class="screen">
      <button id="homeScreenSettingsButton" class="icon-button top-right">
        <span class="material-icons">settings</span>
      </button>
      <div id="homeClockContainer" class="home-clock-container">
        <div id="currentTimeDisplay" class="current-time"></div>
        <canvas id="analogClockCanvas" class="hidden"></canvas>
      </div>
      <div class="home-buttons">
        <button id="focusButton" class="home-button">
          <span class="material-icons">self_improvement</span>集中する
        </button>
        <button id="viewRecordsButton" class="home-button">
          <span class="material-icons">bar_chart</span>記録を見る
        </button>
      </div>
    </div>

    <div id="timerScreen" class="screen hidden">
      <button id="backToHomeFromTimerButton" class="icon-button top-left">
        <span class="material-icons">arrow_back</span>
      </button>
      <h1 id="timerDisplay" class="timer-display">25:00</h1>
      <div class="progress-container">
        <div id="progressBarFill" class="progress-bar"></div>
      </div>
      <div class="button-group">
        <button id="startButton" class="button-primary">
          <span id="startButtonIcon" class="material-icons">play_arrow</span>
          <span id="startButtonText">スタート</span>
        </button>
        <button id="saveProgressButton" class="button-secondary hidden">
          <span class="material-icons">save</span>
          <span>保存</span>
        </button>
      </div>
      <div class="session-info">
        <span id="currentSessionWorkTime">集中: 0分</span>
        <span id="currentSessionBreakTime">休憩: 0分</span>
      </div>
      <button id="stopAlarmButton" class="button-secondary mt-6 hidden">
        <span class="material-icons">alarm_off</span>
        <span>アラームを停止</span>
      </button>
    </div>

    <div id="recordsScreen" class="screen hidden">
      <div class="records-header">
        <button id="backToHomeFromRecordsButton" class="icon-button top-left">
          <span class="material-icons">arrow_back</span>
        </button>
        <h2>記録</h2>
      </div>
      <div class="records-time-unit-buttons">
        <button id="dailyViewButton" class="active">日単位</button>
        <button id="monthlyViewButton">月単位</button>
        <button id="yearlyViewButton">年単位</button>
      </div>
      <div class="chart-scroll-container">
        <canvas id="recordsChartCanvas"></canvas>
      </div>
      <p id="noDataMessage" class="text-gray-600 mt-4 hidden">まだ記録がありません。</p>
    </div>

    <div id="settingsModal" class="modal-overlay hidden">
      <div class="modal-content">
        <h2 class="modal-header">設定</h2>
        <div class="modal-body">
          <label>作業時間:
            <input type="number" id="workTimeInput" min="5" value="25">分
          </label>
          <label>休憩時間:
            <input type="number" id="breakTimeInput" min="1" value="5">分
          </label>
          <label>テーマカラー:
            <input type="color" id="themeColorInput" value="#ef4444">
          </label>
          <label class="flex-col items-start mt-4">時計表示形式:
            <div class="flex items-center mt-2">
              <input type="radio" id="clockFormat24" name="clockFormat" value="24" class="mr-1">
              <span class="text-base">24時間</span>
              <input type="radio" id="clockFormat12" name="clockFormat" value="12" class="ml-6 mr-1">
              <span class="text-base">12時間</span>
            </div>
          </label>
          <label class="flex-col items-start mt-4">アラーム音:
            <div class="flex items-center mt-2 w-full">
              <select id="alarmSoundSelect" class="flex-grow mr-2 p-2 border border-gray-300 rounded-md"></select>
              <input type="file" id="alarmFileInput" accept="audio/mpeg, audio/wav, audio/ogg" class="hidden">
              <button id="addAlarmSoundButton" class="button-secondary p-2 !rounded-lg !shadow-none !text-base">
                <span class="material-icons !text-xl">add</span>
              </button>
              <button id="deleteAlarmSoundButton" class="bg-red-500 text-white p-2 ml-2 !rounded-lg hover:bg-red-600 transition-colors duration-200 !shadow-none !text-base">
                <span class="material-icons !text-xl">delete</span>
              </button>
            </div>
          </label>
          <label class="flex-col items-start mt-4">テーマ:
            <div class="flex flex-col items-start mt-2">
              <label class="inline-flex items-center mb-2">
                <input type="radio" id="themeSystem" name="appTheme" value="system" class="mr-2">
                <span class="text-base">システム設定に従う</span>
              </label>
              <label class="inline-flex items-center mb-2">
                <input type="radio" id="themeLight" name="appTheme" value="light" class="mr-2">
                <span class="text-base">ライト</span>
              </label>
              <label class="inline-flex items-center">
                <input type="radio" id="themeDark" name="appTheme" value="dark" class="mr-2">
                <span class="text-base">ダーク</span>
              </label>
            </div>
          </label>
          <label class="flex-col items-start mt-4">時計表示スタイル:
            <div class="flex flex-col items-start mt-2">
              <label class="inline-flex items-center mb-2">
                <input type="radio" id="clockDisplayFormatDigital" name="clockDisplayFormat" value="digital" class="mr-2">
                <span class="text-base">デジタル</span>
              </label>
              <label class="inline-flex items-center">
                <input type="radio" id="clockDisplayFormatAnalog" name="clockDisplayFormat" value="analog" class="mr-2">
                <span class="text-base">アナログ</span>
              </label>
            </div>
          </label>
        </div>
        <div class="modal-actions">
          <button class="button-cancel" id="cancelSettingsButton">キャンセル</button>
          <button class="button-save" id="saveSettingsButton">保存</button>
        </div>
      </div>
    </div>

    <audio id="alarmSound" src="https://pipocorp-japan.github.io/Pomodoro/alarm.mp3" preload="auto"></audio>

    <div id="customAlertDialog" class="modal-overlay hidden">
      <div class="custom-alert-dialog">
        <p id="alertMessage"></p>
        <div class="modal-actions justify-center">
          <button class="button-cancel" id="alertCancelButton">いいえ</button>
          <button class="button-save" id="alertOkButton">はい</button>
        </div>
      </div>
    </div>

    <script>
    // --- DOM Elements ---
const homeScreen = document.getElementById('homeScreen');
const timerScreen = document.getElementById('timerScreen');
const recordsScreen = document.getElementById('recordsScreen');
const focusButton = document.getElementById('focusButton');
const viewRecordsButton = document.getElementById('viewRecordsButton');
const backToHomeFromTimerButton = document.getElementById('backToHomeFromTimerButton');
const backToHomeFromRecordsButton = document.getElementById('backToHomeFromRecordsButton');
const noDataMessage = document.getElementById('noDataMessage');
const homeScreenSettingsButton = document.getElementById('homeScreenSettingsButton');
const currentTimeDisplay = document.getElementById('currentTimeDisplay');
const homeClockContainer = document.getElementById('homeClockContainer'); // New container for clock
const analogClockCanvas = document.getElementById('analogClockCanvas'); // New canvas element
const analogClockCtx = analogClockCanvas ? analogClockCanvas.getContext('2d') : null;


const timerDisplay = document.getElementById('timerDisplay');
const startButton = document.getElementById('startButton');
const startButtonIcon = document.getElementById('startButtonIcon');
const startButtonText = document.getElementById('startButtonText');
const saveProgressButton = document.getElementById('saveProgressButton');
const settingsModal = document.getElementById('settingsModal');
const workTimeInput = document.getElementById('workTimeInput');
const breakTimeInput = document.getElementById('breakTimeInput');
const themeColorInput = document.getElementById('themeColorInput');
const clockFormat24 = document.getElementById('clockFormat24');
const clockFormat12 = document.getElementById('clockFormat12');
const saveSettingsButton = document.getElementById('saveSettingsButton');
const cancelSettingsButton = document.getElementById('cancelSettingsButton');

// --- Alarm Sound Elements ---
const alarmSoundSelect = document.getElementById('alarmSoundSelect');
const alarmFileInput = document.getElementById('alarmFileInput');
const addAlarmSoundButton = document.getElementById('addAlarmSoundButton');
const deleteAlarmSoundButton = document.getElementById('deleteAlarmSoundButton');
const stopAlarmButton = document.getElementById('stopAlarmButton');

// --- Theme Elements ---
const themeSystem = document.getElementById('themeSystem');
const themeLight = document.getElementById('themeLight');
const themeDark = document.getElementById('themeDark');

// --- Clock Display Format Elements ---
const clockDisplayFormatDigital = document.getElementById('clockDisplayFormatDigital');
const clockDisplayFormatAnalog = document.getElementById('clockDisplayFormatAnalog');


const customAlertDialog = document.getElementById('customAlertDialog');
const alertMessage = document.getElementById('alertMessage');
let alertOkButton = document.getElementById('alertOkButton');
let alertCancelButton = document.getElementById('alertCancelButton');

// Progress bar elements
const progressBarFill = document.getElementById('progressBarFill');

// Session time display elements
const currentSessionWorkTime = document.getElementById('currentSessionWorkTime');
const currentSessionBreakTime = document.getElementById('currentSessionBreakTime');

const recordsChartCanvas = document.getElementById('recordsChartCanvas');
let recordsChart; // To hold the Chart.js instance

// Records time unit buttons
const dailyViewButton = document.getElementById('dailyViewButton');
const monthlyViewButton = document.getElementById('monthlyViewButton');
const yearlyViewButton = document.getElementById('yearlyViewButton');

// --- Variables ---
let workTime = parseInt(localStorage.getItem('pomodoroWorkTime') || '25');
let breakTime = parseInt(localStorage.getItem('pomodoroBreakTime') || '5');
let themeColor = localStorage.getItem('pomodoroThemeColor') || '#ef4444';
let clockFormat = localStorage.getItem('pomodoroClockFormat') || '24'; // '24' or '12'
let appTheme = localStorage.getItem('pomodoroAppTheme') || 'system'; // 'system', 'light', 'dark'
let clockDisplayFormat = localStorage.getItem('pomodoroClockDisplayFormat') || 'digital'; // 'digital' or 'analog'

let currentTimeInSeconds = workTime * 60;
let totalPeriodSeconds = workTime * 60; // Total seconds for the current period
let isRunning = false;
let timerInterval = null; // Initialize to null
let isWorkPeriod = true; // true for work, false for break
let currentTimeInterval = null; // For home screen clock (global scope)

// New variables for precise timer
let timerStartTime = null; // Stores timestamp when timer actually started/resumed (in milliseconds)
let remainingTimeAtLastStart = workTime * 60; // Stores remaining seconds when timer was last started or after a pause


// Session accumulated times (reset on full cycle completion or manual save)
let sessionFocusedSeconds = 0;
let sessionBreakSeconds = 0;

const RECORDS_KEY = 'pomodoroRecords';
let currentChartTimeUnit = 'day'; // 'day', 'month', 'year'

// --- Audio ---
const alarmSound = document.getElementById('alarmSound'); // audio要素を取得
let audioUnlocked = false; // Add a flag to track if audio context is unlocked
let isAlarmPlaying = false; // Track if alarm is currently playing

// Listener for system theme changes
const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
let systemThemeChangeListener = null; // To store the listener for removal

// --- Alarm Sound Storage (IndexedDB) ---
const DB_NAME = 'pomodoro_db';
const STORE_NAME = 'alarm_sounds';
let db;

async function openIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
        };

        request.onerror = (event) => {
            console.error("IndexedDB error:", event.target.errorCode);
            reject(event.target.errorCode);
        };
    });
}

async function saveAlarmSound(name, dataUrl) {
    if (!db) await openIndexedDB(); // Ensure DB is open
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.add({ name: name, data: dataUrl });

        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
    });
}

async function deleteAlarmSound(id) {
    if (!db) await openIndexedDB(); // Ensure DB is open
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(id);

        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
    });
}

async function getAlarmSounds() {
    if (!db) await openIndexedDB(); // Ensure DB is open
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = () => resolve(request.result);
        request.onerror = (event) => reject(event.target.error);
    });
}

async function loadAlarmSoundsToSelect() {
    const sounds = await getAlarmSounds();
    alarmSoundSelect.innerHTML = ''; // Clear existing options

    // Default option
    const defaultOption = document.createElement('option');
    defaultOption.value = 'default';
    defaultOption.textContent = 'デフォルト';
    alarmSoundSelect.appendChild(defaultOption);

    sounds.forEach(sound => {
        const option = document.createElement('option');
        option.value = sound.id;
        option.textContent = sound.name;
        alarmSoundSelect.appendChild(option);
    });

    // Add "+" option at the bottom
    const addOption = document.createElement('option');
    addOption.value = 'add_new';
    addOption.textContent = '+ カスタム音を追加';
    alarmSoundSelect.appendChild(addOption);

    // Set selected value from localStorage or default
    const savedAlarmId = localStorage.getItem('pomodoroAlarmSoundId') || 'default';
    alarmSoundSelect.value = savedAlarmId;

    // Set the audio src immediately
    if (savedAlarmId === 'default') {
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
        deleteAlarmSoundButton.classList.add('hidden'); // Hide delete button for default
    } else if (savedAlarmId === 'add_new') {
        // If '+' was selected previously (shouldn't happen on load if logic is correct)
        // Revert to default or handle error. For now, revert to default.
        alarmSoundSelect.value = 'default';
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
        localStorage.setItem('pomodoroAlarmSoundId', 'default');
        deleteAlarmSoundButton.classList.add('hidden'); // Hide delete button for default
    } else {
        const selectedSound = sounds.find(s => s.id == savedAlarmId); // Use == for loose comparison as ID can be number/string
        if (selectedSound) {
            alarmSound.src = selectedSound.data;
            deleteAlarmSoundButton.classList.remove('hidden'); // Show delete button for custom
        } else {
            // If saved ID not found (e.g., sound deleted), revert to default
            alarmSoundSelect.value = 'default';
            alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
            localStorage.setItem('pomodoroAlarmSoundId', 'default');
            deleteAlarmSoundButton.classList.add('hidden'); // Hide delete button for default
        }
    }
}

function playAlarmSound() {
    // Stop any currently playing alarm to avoid overlaps
    alarmSound.pause();
    alarmSound.currentTime = 0;

    if (audioUnlocked) {
        alarmSound.volume = 0.5;
        alarmSound.play().then(() => {
            isAlarmPlaying = true;
            stopAlarmButton.classList.remove('hidden');
        }).catch(error => {
            console.warn("アラーム音の再生に失敗しました:", error);
            if (error.name === 'NotAllowedError' || error.name === 'AbortError') {
                showCustomAlertDialog('アラーム音の再生には、ページとのインタラクション（例: 開始ボタンのクリック）が必要です。', () => {}, () => {});
            } else if (error.name === 'NotSupportedError') {
                 showCustomAlertDialog('このアラーム音は再生できませんでした。別のファイルをお試しください。', () => {}, () => {});
            }
        });
    } else {
        console.log("Audio not unlocked yet. Waiting for user interaction.");
        // Try to unlock audio context silently on first user interaction
        alarmSound.volume = 0;
        alarmSound.play().then(() => {
            alarmSound.pause();
            alarmSound.currentTime = 0;
            alarmSound.volume = 0.5;
            audioUnlocked = true;
            console.log("Audio unlocked silently.");
            playAlarmSound(); // Now that it's unlocked, try playing the actual alarm sound again
        }).catch(error => {
            console.warn("Silent audio unlock failed:", error);
            // If silent unlock fails, we'll need a direct user interaction for audio.
            showCustomAlertDialog('アラーム音の再生には、ページとのインタラクションが必要です。', () => {}, () => {});
        });
    }
}

function stopAlarmSound() {
    if (isAlarmPlaying) {
        alarmSound.pause();
        alarmSound.currentTime = 0;
        isAlarmPlaying = false;
        stopAlarmButton.classList.add('hidden');
    }
}

// Function to unlock audio on first user interaction
function unlockAudio() {
    if (!audioUnlocked) {
        // Attempt to play a silent sound to unlock the audio context
        alarmSound.volume = 0;
        alarmSound.play().then(() => {
            alarmSound.pause();
            alarmSound.currentTime = 0;
            alarmSound.volume = 0.5;
            audioUnlocked = true;
            console.log("Audio unlocked by user interaction.");
        }).catch(error => {
            console.warn("Failed to unlock audio with user interaction:", error);
        });
    }
}

// --- Utility Functions ---
function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
}

function formatCurrentTime(date) {
    let hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    let ampm = '';

    if (clockFormat === '12') {
        ampm = hours >= 12 ? ' PM' : ' AM';
        hours = hours % 12;
        hours = hours ? hours : 12; // The hour '0' should be '12' in 12-hour format
    }

    // Always pad hours for consistent width in digital display
    const formattedHours = String(hours).padStart(2, '0');

    return `${formattedHours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}${ampm}`;
}

function updateCurrentTimeDisplay() {
    const now = new Date();
    currentTimeDisplay.textContent = formatCurrentTime(now);
}

// Sets the accent color of the app
function setThemeColors(color) {
    // Update both light and dark mode specific accent colors
    document.documentElement.style.setProperty('--primary-color-light', color);
    const hexToRgb = (hex) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    };

    const rgbToHex = (r, g, b) => {
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    };

    const { r, g, b } = hexToRgb(color);
    const darkerColor = rgbToHex(
        Math.max(0, r - 30),
        Math.max(0, g - 30),
        Math.max(0, b - 30)
    );
    document.documentElement.style.setProperty('--primary-color-dark-light', darkerColor);

    // For dark mode, we might want a slightly lighter primary color for contrast
    const lighterColor = rgbToHex(
        Math.min(255, r + 30),
        Math.min(255, g + 30),
        Math.min(255, b + 30)
    );
    document.documentElement.style.setProperty('--primary-color-dark-mode', lighterColor);
    document.documentElement.style.setProperty('--primary-color-darker-dark-mode', color); // Original as darker for dark mode hover

    document.documentElement.style.setProperty('--primary-color-rgb', `${r}, ${g}, ${b}`); // Keep original RGB for shadows

    // Update chart colors immediately if chart exists
    if (recordsChart) {
        renderRecordsChart(currentChartTimeUnit); // Re-render to pick up new colors
    }
}

// Manages the overall app theme (light/dark/system)
function setAppTheme(mode) {
    appTheme = mode;
    localStorage.setItem('pomodoroAppTheme', mode);

    // Remove any existing theme-specific classes
    document.body.classList.remove('light-mode', 'dark-mode');

    // Remove old system theme listener if exists
    if (systemThemeChangeListener) {
        prefersDarkScheme.removeListener(systemThemeChangeListener);
        systemThemeChangeListener = null;
    }

    if (mode === 'light') {
        document.body.classList.add('light-mode');
    } else if (mode === 'dark') {
        document.body.classList.add('dark-mode');
    } else { // 'system' mode
        // Add a listener to switch theme based on system preference
        systemThemeChangeListener = (e) => {
            if (e.matches) {
                document.body.classList.add('dark-mode');
                document.body.classList.remove('light-mode');
            } else {
                document.body.classList.add('light-mode');
                document.body.classList.remove('dark-mode');
            }
            // Ensure chart colors are updated if the system theme changes
            if (recordsChart) {
                renderRecordsChart(currentChartTimeUnit);
            }
        };
        prefersDarkScheme.addListener(systemThemeChangeListener);
        // Apply initial system theme
        systemThemeChangeListener(prefersDarkScheme);
    }
    // Re-apply the primary accent color based on current theme context and the stored themeColor
    setThemeColors(themeColorInput.value);

    // Update chart colors when app theme changes
    if (recordsChart) {
        renderRecordsChart(currentChartTimeUnit);
    }
}

// Sets the clock display mode (digital/analog)
function setClockDisplayMode(mode) {
    clockDisplayFormat = mode;
    localStorage.setItem('pomodoroClockDisplayFormat', mode);

    // Clear any existing clock intervals
    if (currentTimeInterval) {
        clearInterval(currentTimeInterval);
        currentTimeInterval = null;
    }
    // Always clear canvas when changing display mode or leaving home screen
    if (analogClockCtx) {
        analogClockCtx.clearRect(0, 0, analogClockCanvas.width, analogClockCanvas.height);
    }


    if (mode === 'digital') {
        currentTimeDisplay.classList.remove('hidden');
        analogClockCanvas.classList.add('hidden');
        homeClockContainer.style.height = 'auto'; // Revert container height for digital
        currentTimeInterval = setInterval(updateCurrentTimeDisplay, 1000);
        updateCurrentTimeDisplay(); // Initial update
    } else { // 'analog'
        currentTimeDisplay.classList.add('hidden');
        analogClockCanvas.classList.remove('hidden');
        // Set canvas dimensions based on container or fixed size for analog clock
        const containerRect = homeClockContainer.getBoundingClientRect();
        const size = Math.min(containerRect.width, containerRect.height); // Use actual rendered size of the container
        analogClockCanvas.width = size;
        analogClockCanvas.height = size;
        currentTimeInterval = setInterval(drawAnalogClock, 1000);
        drawAnalogClock(); // Initial draw
    }
}


function updateDisplay() {
    timerDisplay.textContent = formatTime(currentTimeInSeconds);

    totalPeriodSeconds = isWorkPeriod ? workTime * 60 : breakTime * 60;

    const progressPercentage = totalPeriodSeconds > 0 ? ((totalPeriodSeconds - currentTimeInSeconds) / totalPeriodSeconds) * 100 : 0;
    progressBarFill.style.width = `${progressPercentage}%`;
    progressBarFill.style.backgroundColor = isWorkPeriod ? 'var(--primary-color)' : 'var(--secondary-period-color)';

    timerDisplay.style.color = isWorkPeriod ? 'var(--primary-color)' : 'var(--secondary-period-color)';

    updateTimerButtonVisibility();

    let displayWorkMins = Math.floor(sessionFocusedSeconds / 60);
    let displayBreakMins = Math.floor(sessionBreakSeconds / 60);

    currentSessionWorkTime.textContent = `集中: ${displayWorkMins}分`;
    currentSessionBreakTime.textContent = `休憩: ${displayBreakMins}分`;
}

function updateTimer() {
    if (!isRunning) return;

    const now = Date.now();
    const elapsedTime = Math.floor((now - timerStartTime) / 1000); // Elapsed time in seconds
    currentTimeInSeconds = remainingTimeAtLastStart - elapsedTime;

    if (currentTimeInSeconds <= 0) {
        currentTimeInSeconds = 0; // Ensure it doesn't go negative
        clearInterval(timerInterval);
        timerInterval = null; // Clear interval reference
        playAlarmSound(); // Play alarm when timer ends

        // Calculate and add the elapsed time for the just-finished period to sessionFocusedSeconds/sessionBreakSeconds
        // This makes sure the full period time is counted
        if (isWorkPeriod) {
            sessionFocusedSeconds += (remainingTimeAtLastStart); // Add the full amount of time that was in this period
        } else {
            sessionBreakSeconds += (remainingTimeAtLastStart);
        }
        updateDisplay(); // Final display update to show 00:00

        if (isWorkPeriod) {
            // Work period ended, start break
            showCustomAlertDialog(
                '集中時間終了！休憩に入りますか？\n（「はい」で休憩開始、「いいえ」で集中時間を保存しホームに戻ります）',
                () => {
                    // This path means continue to break. Save the just finished work session.
                    saveRecord(); // Save the completed work session
                    isWorkPeriod = false;
                    currentTimeInSeconds = breakTime * 60;
                    remainingTimeAtLastStart = breakTime * 60; // Set initial for break period
                    startButtonText.textContent = '休憩開始';
                    startButtonIcon.textContent = 'play_arrow'; // Material Icon
                    startButton.classList.remove('hidden');
                    saveProgressButton.classList.add('hidden'); // Hide save button before break starts
                    startTimer(); // Automatically start break using the startTimer function
                },
                () => {
                    // This path means go to home. Save the just finished work session.
                    saveRecord(); // Save the completed work session
                    resetTimer();
                    showScreen('home');
                }
            );
        } else {
            // Break period ended, suggest new work period
            showCustomAlertDialog(
                '休憩時間終了！新しい集中を始めますか？\n（「はい」で集中開始、「いいえ」で休憩時間を保存しホームに戻ります）',
                () => {
                    // This path means continue to next work period. Save the just finished break session.
                    saveRecord(); // Save the completed break session
                    isWorkPeriod = true;
                    currentTimeInSeconds = workTime * 60;
                    remainingTimeAtLastStart = workTime * 60; // Set initial for work period
                    startButtonText.textContent = 'スタート';
                    startButtonIcon.textContent = 'play_arrow'; // Material Icon
                    startButton.classList.remove('hidden');
                    saveProgressButton.classList.add('hidden'); // Hide save button before work starts
                    startTimer(); // Automatically start new work period
                },
                () => {
                    // This path means go to home. Save the just finished break session.
                    saveRecord(); // Save the completed break session
                    resetTimer();
                    showScreen('home');
                }
            );
        }
    } else {
        // Only update session accumulated time if timer is still running (not hit 0)
        // This prevents double counting if `updateTimer` is called again right after hitting 0
        if (isWorkPeriod) {
            sessionFocusedSeconds = (workTime * 60) - currentTimeInSeconds;
        } else {
            sessionBreakSeconds = (breakTime * 60) - currentTimeInSeconds;
        }
        updateDisplay();
    }
}

function startTimer() {
    unlockAudio(); // Attempt to unlock audio on start
    if (!isRunning) {
        isRunning = true;
        timerStartTime = Date.now(); // Record start time
        if (timerInterval) clearInterval(timerInterval); // Clear any existing interval before setting a new one
        timerInterval = setInterval(updateTimer, 1000);
        startButtonText.textContent = '一時停止';
        startButtonIcon.textContent = 'pause'; // Material Icon
        saveProgressButton.classList.remove('hidden'); // Show save button when running or paused
    } else {
        pauseTimer();
    }
}

function pauseTimer() {
    isRunning = false;
    clearInterval(timerInterval);
    timerInterval = null; // Clear interval reference
    remainingTimeAtLastStart = currentTimeInSeconds; // Save current time for accurate resume
    timerStartTime = null; // Clear start time
    startButtonText.textContent = '再開';
    startButtonIcon.textContent = 'play_arrow'; // Material Icon
    saveProgressButton.classList.remove('hidden'); // Keep save button visible when paused
}

function resetTimer() {
    pauseTimer(); // Ensure interval is cleared and state is paused
    currentTimeInSeconds = workTime * 60; // Reset to full work time
    remainingTimeAtLastStart = workTime * 60; // Reset for a clean start
    isWorkPeriod = true;
    sessionFocusedSeconds = 0; // Reset session times
    sessionBreakSeconds = 0;   // Reset session times
    updateDisplay();
    startButtonText.textContent = 'スタート';
    startButtonIcon.textContent = 'play_arrow'; // Material Icon
    saveProgressButton.classList.add('hidden'); // Hide save button on full reset
    stopAlarmSound(); // Ensure alarm is stopped
}

function updateTimerButtonVisibility() {
    if (isRunning) {
        // If timer is running
        startButton.classList.remove('hidden'); // Show start/pause button
        saveProgressButton.classList.remove('hidden'); // Show save button
    } else {
        // If timer is paused or stopped
        startButton.classList.remove('hidden'); // Always show start/resume button
        if (sessionFocusedSeconds > 0 || sessionBreakSeconds > 0) {
            saveProgressButton.classList.remove('hidden'); // Show save if any time accumulated
        } else {
            saveProgressButton.classList.add('hidden'); // Hide save if no time accumulated (fresh start)
        }
    }
}

function saveRecord() {
    // Only save if there's actual focused or break time accumulated in the session
    if (sessionFocusedSeconds === 0 && sessionBreakSeconds === 0) {
        console.log("No time to record for this session.");
        return;
    }

    const records = JSON.parse(localStorage.getItem(RECORDS_KEY) || '[]');
    const now = new Date();
    const dateString = now.toISOString().split('T')[0]; // budou-MM-DD

    let recordFound = false;
    for (let i = 0; i < records.length; i++) {
        if (records[i].date === dateString) {
            records[i].focusedMinutes = (records[i].focusedMinutes || 0) + Math.floor(sessionFocusedSeconds / 60);
            records[i].breakMinutes = (records[i].breakMinutes || 0) + Math.floor(sessionBreakSeconds / 60);
            recordFound = true;
            break;
        }
    }

    if (!recordFound) {
        records.push({
            date: dateString,
            focusedMinutes: Math.floor(sessionFocusedSeconds / 60),
            breakMinutes: Math.floor(sessionBreakSeconds / 60)
        });
    }

    localStorage.setItem(RECORDS_KEY, JSON.stringify(records));
    sessionFocusedSeconds = 0; // Reset after saving
    sessionBreakSeconds = 0;   // Reset after saving
    updateDisplay(); // Update session info display
    console.log("Record saved. Current records in localStorage:", records); // Added log
}

function showCustomAlertDialog(message, onOk, onCancel) {
    alertMessage.textContent = message;
    customAlertDialog.classList.remove('hidden');
    customAlertDialog.classList.add('visible');

    const handleOk = () => {
        onOk();
        customAlertDialog.classList.remove('visible');
        // Use a timeout to apply 'hidden' after transition
        setTimeout(() => {
            customAlertDialog.classList.add('hidden');
        }, 300); // Match CSS transition duration
        alertOkButton.removeEventListener('click', handleOk);
        alertCancelButton.removeEventListener('click', handleCancel);
    };

    const handleCancel = () => {
        if (onCancel) onCancel();
        customAlertDialog.classList.remove('visible');
        setTimeout(() => {
            customAlertDialog.classList.add('hidden');
        }, 300);
        alertOkButton.removeEventListener('click', handleOk);
        alertCancelButton.removeEventListener('click', handleCancel);
    };

    alertOkButton.addEventListener('click', handleOk);
    alertCancelButton.addEventListener('click', handleCancel);
}

// --- Screen Management ---
function showScreen(screenId) {
    const screens = [homeScreen, timerScreen, recordsScreen];
    screens.forEach(screen => {
        if (screen.id === screenId + 'Screen') {
            screen.classList.remove('hidden');
            // Trigger reflow to ensure transition plays
            void screen.offsetWidth;
            screen.classList.add('visible');
        } else {
            screen.classList.remove('visible');
            // Use a timeout to apply 'hidden' after transition
            setTimeout(() => {
                screen.classList.add('hidden');
            }, 400); // Match CSS transition duration
        }
    });

    if (screenId === 'home') {
        setClockDisplayMode(clockDisplayFormat); // Re-apply clock display mode for home screen
    } else {
        if (currentTimeInterval) {
            clearInterval(currentTimeInterval);
            currentTimeInterval = null;
        }
        // Always clear canvas when leaving home screen
        if (analogClockCtx) {
            analogClockCtx.clearRect(0, 0, analogClockCanvas.width, analogClockCanvas.height);
        }
    }
    if (screenId === 'records') {
        renderRecordsChart(currentChartTimeUnit);
    }
}

// --- Analog Clock Drawing ---
function drawAnalogClock() {
    if (!analogClockCtx) return;

    const now = new Date();
    let hours = now.getHours();
    let minutes = now.getMinutes();
    let seconds = now.getSeconds();

    // Get live CSS variables for drawing
    const handColor = getComputedStyle(document.documentElement).getPropertyValue('--analog-hand-color').trim();
    // Use --primary-color for the second hand
    const secondHandColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
    const surfaceColor = getComputedStyle(document.documentElement).getPropertyValue('--surface-color').trim();
    const onSurfaceColor = getComputedStyle(document.documentElement).getPropertyValue('--on-surface').trim();

    // Set canvas dimensions dynamically
    // Use clientWidth/clientHeight of the container to ensure the canvas drawing surface matches its display size
    const containerRect = homeClockContainer.getBoundingClientRect();
    const size = Math.min(containerRect.width, containerRect.height); // This ensures it's always square
    analogClockCanvas.width = size;
    analogClockCanvas.height = size;

    const centerX = analogClockCanvas.width / 2;
    const centerY = analogClockCanvas.height / 2;
    const radius = Math.min(centerX, centerY) * 0.85; // Slightly smaller than container

    // Clear canvas
    analogClockCtx.clearRect(0, 0, analogClockCanvas.width, analogClockCanvas.height);

    // Draw clock border
    analogClockCtx.beginPath();
    analogClockCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    analogClockCtx.strokeStyle = onSurfaceColor; // Border color
    analogClockCtx.lineWidth = 2;
    analogClockCtx.stroke();

    // Draw hour marks
    for (let i = 0; i < 12; i++) {
        const angle = (i * 30 * Math.PI) / 180; // 30 degrees per hour
        const x1 = centerX + radius * 0.9 * Math.sin(angle);
        const y1 = centerY - radius * 0.9 * Math.cos(angle);
        const x2 = centerX + radius * 0.8 * Math.sin(angle);
        const y2 = centerY - radius * 0.8 * Math.cos(angle);
        analogClockCtx.beginPath();
        analogClockCtx.moveTo(x1, y1);
        analogClockCtx.lineTo(x2, y2);
        analogClockCtx.strokeStyle = onSurfaceColor;
        analogClockCtx.lineWidth = 2;
        analogClockCtx.stroke();

        // Draw hour numbers
        analogClockCtx.font = `${radius * 0.15}px 'Inter'`; // Dynamic font size
        analogClockCtx.textAlign = 'center';
        analogClockCtx.textBaseline = 'middle';
        analogClockCtx.fillStyle = onSurfaceColor;
        // Corrected calculation for numX and numY for perfect centering
        const numX = centerX + radius * 0.7 * Math.sin(angle);
        const numY = centerY - radius * 0.7 * Math.cos(angle);
        analogClockCtx.fillText(i === 0 ? 12 : i, numX, numY);
    }

    // Draw minute marks
    for (let i = 0; i < 60; i++) {
        if (i % 5 !== 0) { // Skip hour marks
            const angle = (i * 6 * Math.PI) / 180; // 6 degrees per minute
            const x1 = centerX + radius * 0.95 * Math.sin(angle);
            const y1 = centerY - radius * 0.95 * Math.cos(angle);
            const x2 = centerX + radius * 0.92 * Math.sin(angle);
            const y2 = centerY - radius * 0.92 * Math.cos(angle);
            analogClockCtx.beginPath();
            analogClockCtx.moveTo(x1, y1);
            analogClockCtx.lineTo(x2, y2);
            analogClockCtx.strokeStyle = onSurfaceColor;
            analogClockCtx.lineWidth = 1;
            analogClockCtx.stroke();
        }
    }

    // Draw hour hand
    let hourAngle = ((hours % 12) + minutes / 60 + seconds / 3600) * 30 * Math.PI / 180;
    drawHand(centerX, centerY, hourAngle, radius * 0.5, 6, handColor);

    // Draw minute hand
    let minuteAngle = (minutes + seconds / 60) * 6 * Math.PI / 180;
    drawHand(centerX, centerY, minuteAngle, radius * 0.75, 4, handColor);

    // Draw second hand
    let secondAngle = seconds * 6 * Math.PI / 180;
    drawHand(centerX, centerY, secondAngle, radius * 0.8, 2, secondHandColor);

    // Draw center circle
    analogClockCtx.beginPath();
    analogClockCtx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
    analogClockCtx.fillStyle = secondHandColor;
    analogClockCtx.fill();
}

function drawHand(x, y, angle, length, width, color) {
    if (!analogClockCtx) return;
    analogClockCtx.beginPath();
    analogClockCtx.lineWidth = width;
    analogClockCtx.lineCap = 'round';
    analogClockCtx.strokeStyle = color;
    analogClockCtx.moveTo(x, y);
    // Adjust angle by -Math.PI / 2 to start from 12 o'clock (upwards)
    analogClockCtx.lineTo(x + length * Math.sin(angle), y - length * Math.cos(angle));
    analogClockCtx.stroke();
}


// --- Event Listeners ---
focusButton.addEventListener('click', () => {
    showScreen('timer');
    resetTimer(); // Ensure timer is reset when entering focus mode
    updateDisplay(); // Initialize display
});

viewRecordsButton.addEventListener('click', () => {
    showScreen('records');
    renderRecordsChart(currentChartTimeUnit);
});

backToHomeFromTimerButton.addEventListener('click', () => {
    if (isRunning || sessionFocusedSeconds > 0 || sessionBreakSeconds > 0) {
        showCustomAlertDialog(
            'タイマーを中断してホームに戻りますか？\n現在の集中/休憩時間は保存されません。',
            () => {
                resetTimer();
                stopAlarmSound();
                showScreen('home');
            },
            () => {
                // Do nothing, stay on timer screen
            }
            );
        } else {
            showScreen('home');
            resetTimer(); // Reset only if no time was accumulated or running
            stopAlarmSound();
        }
});

backToHomeFromRecordsButton.addEventListener('click', () => {
    showScreen('home');
});

startButton.addEventListener('click', startTimer);
saveProgressButton.addEventListener('click', () => {
    // When saving mid-period, the actual elapsed time needs to be accounted for.
    // pauseTimer() will set remainingTimeAtLastStart, so we can use currentTimeInSeconds directly here.
    pauseTimer(); // Ensure timer is paused and remainingTimeAtLastStart is updated
    saveRecord();
    resetTimer();
    showScreen('home');
});

homeScreenSettingsButton.addEventListener('click', () => {
    // Populate settings modal with current values
    workTimeInput.value = workTime;
    breakTimeInput.value = breakTime;
    themeColorInput.value = themeColor;
    if (clockFormat === '24') {
        clockFormat24.checked = true;
    } else {
        clockFormat12.checked = true;
    }
    // Set theme radio button
    document.querySelector(`input[name="appTheme"][value="${appTheme}"]`).checked = true;
    // Set clock display format radio button
    document.querySelector(`input[name="clockDisplayFormat"][value="${clockDisplayFormat}"]`).checked = true;


    loadAlarmSoundsToSelect(); // Load custom sounds
    settingsModal.classList.remove('hidden');
    settingsModal.classList.add('visible');
});

cancelSettingsButton.addEventListener('click', () => {
    settingsModal.classList.remove('visible');
    setTimeout(() => {
        settingsModal.classList.add('hidden');
    }, 300);
});

saveSettingsButton.addEventListener('click', () => {
    workTime = parseInt(workTimeInput.value);
    breakTime = parseInt(breakTimeInput.value);
    themeColor = themeColorInput.value;
    clockFormat = clockFormat24.checked ? '24' : '12';
    appTheme = document.querySelector('input[name="appTheme"]:checked').value; // Get selected theme
    clockDisplayFormat = document.querySelector('input[name="clockDisplayFormat"]:checked').value; // Get selected clock display format

    localStorage.setItem('pomodoroWorkTime', workTime);
    localStorage.setItem('pomodoroBreakTime', breakTime);
    localStorage.setItem('pomodoroThemeColor', themeColor);
    localStorage.setItem('pomodoroClockFormat', clockFormat);
    localStorage.setItem('pomodoroAppTheme', appTheme); // Save theme setting
    localStorage.setItem('pomodoroClockDisplayFormat', clockDisplayFormat); // Save clock display format
    localStorage.setItem('pomodoroAlarmSoundId', alarmSoundSelect.value); // Save selected alarm sound ID

    setAppTheme(appTheme); // Apply the new app theme (and re-apply accent color within it)
    setClockDisplayMode(clockDisplayFormat); // Apply the new clock display mode
    resetTimer(); // Reset timer to apply new work/break times
    console.log("設定が保存されました。新しい作業時間:", workTime, "リセット後の現在の時間:", currentTimeInSeconds); // Debugging line
    updateDisplay(); // Update display with new times
    // updateCurrentTimeDisplay() is now handled by setClockDisplayMode
    // renderRecordsChart() is also handled by setAppTheme if theme changes cause re-render

    // Set actual alarm sound src based on selection
    if (alarmSoundSelect.value === 'default') {
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
    } else {
        getAlarmSounds().then(sounds => {
            const selectedSound = sounds.find(s => s.id == alarmSoundSelect.value);
            if (selectedSound) {
                alarmSound.src = selectedSound.data;
            } else {
                // Fallback if selected custom sound is no longer available
                alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                localStorage.setItem('pomodoroAlarmSoundId', 'default');
                alarmSoundSelect.value = 'default';
            }
        });
    }

    settingsModal.classList.remove('visible');
    setTimeout(() => {
        settingsModal.classList.add('hidden');
    }, 300);
});

// Alarm sound selection change handler
alarmSoundSelect.addEventListener('change', async (event) => {
    const selectedValue = event.target.value;
    if (selectedValue === 'add_new') {
        alarmFileInput.click(); // Trigger file input
        alarmSoundSelect.value = localStorage.getItem('pomodoroAlarmSoundId') || 'default'; // Revert selection
    } else if (selectedValue === 'default') {
        deleteAlarmSoundButton.classList.add('hidden');
        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
    } else {
        deleteAlarmSoundButton.classList.remove('hidden');
        const sounds = await getAlarmSounds();
        const selectedSound = sounds.find(s => s.id == selectedValue);
        if (selectedSound) {
            alarmSound.src = selectedSound.data;
        }
    }
});

// Handling file input for custom alarm sounds
alarmFileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        if (!file.type.startsWith('audio/')) {
            showCustomAlertDialog('音声ファイルを選択してください。', () => {}, () => {});
            return;
        }

        const reader = new FileReader();
        reader.onload = async (e) => {
            const dataUrl = e.target.result;
            const soundName = file.name.split('.').slice(0, -1).join('.'); // Get name without extension
            try {
                await saveAlarmSound(soundName, dataUrl);
                await loadAlarmSoundsToSelect(); // Reload options including new sound
                // Attempt to select the newly added sound by finding its ID
                const newlyAddedSound = (await getAlarmSounds()).find(s => s.name === soundName && s.data === dataUrl);
                if (newlyAddedSound) {
                    alarmSoundSelect.value = newlyAddedSound.id;
                    localStorage.setItem('pomodoroAlarmSoundId', newlyAddedSound.id);
                    alarmSound.src = dataUrl; // Set alarm audio source
                    deleteAlarmSoundButton.classList.remove('hidden'); // Show delete button
                } else {
                    // Fallback if for some reason the sound couldn't be found after saving
                    console.warn("Newly added sound not found in select list, reverting to default.");
                    alarmSoundSelect.value = 'default';
                    alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                    localStorage.setItem('pomodoroAlarmSoundId', 'default');
                    deleteAlarmSoundButton.classList.add('hidden');
                }
            } catch (error) {
                console.error("Failed to save or load alarm sound:", error);
                showCustomAlertDialog('アラーム音の保存に失敗しました。', () => {}, () => {});
            }
        };
        reader.readAsDataURL(file);
    }
});

deleteAlarmSoundButton.addEventListener('click', async () => {
    const selectedId = alarmSoundSelect.value;
    if (selectedId !== 'default') {
        showCustomAlertDialog('選択したアラーム音を削除しますか？', async () => {
            try {
                await deleteAlarmSound(parseInt(selectedId));
                await loadAlarmSoundsToSelect();
                // If the deleted sound was currently selected, revert to default
                if (localStorage.getItem('pomodoroAlarmSoundId') == selectedId) { // Use == for comparison
                    localStorage.setItem('pomodoroAlarmSoundId', 'default');
                }
                alarmSoundSelect.value = localStorage.getItem('pomodoroAlarmSoundId') || 'default';
                // Re-evaluate the src and delete button visibility based on the new selection
                if (alarmSoundSelect.value === 'default') {
                    alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                    deleteAlarmSoundButton.classList.add('hidden');
                } else {
                    const sounds = await getAlarmSounds();
                    const selectedSound = sounds.find(s => s.id == alarmSoundSelect.value);
                    if (selectedSound) {
                        alarmSound.src = selectedSound.data;
                        deleteAlarmSoundButton.classList.remove('hidden');
                    } else {
                        // Fallback if the new selected ID is also somehow invalid
                        alarmSoundSelect.value = 'default';
                        alarmSound.src = 'https://pipocorp-japan.github.io/Pomodoro/alarm.mp3';
                        localStorage.setItem('pomodoroAlarmSoundId', 'default');
                        deleteAlarmSoundButton.classList.add('hidden');
                    }
                }
            } catch (error) {
                console.error("Failed to delete alarm sound:", error);
                showCustomAlertDialog('アラーム音の削除に失敗しました。', () => {}, () => {});
            }
        }, () => {});
    }
});

stopAlarmButton.addEventListener('click', stopAlarmSound);

// --- Chart.js for Records ---
function renderRecordsChart(timeUnit) {
    console.log("Rendering chart with time unit:", timeUnit); // Debug log
    const records = JSON.parse(localStorage.getItem(RECORDS_KEY) || '[]');
    console.log("Raw records from localStorage:", records); // Debug log

    if (records.length === 0) {
        noDataMessage.classList.remove('hidden');
        if (recordsChart) {
            recordsChart.destroy(); // Destroy existing chart if no data
            recordsChart = null;
        }
        recordsChartCanvas.classList.add('hidden'); // Hide canvas if no data
        return;
    } else {
        noDataMessage.classList.add('hidden');
        recordsChartCanvas.classList.remove('hidden');
    }

    const processedData = processRecordsForChart(records, timeUnit);
    console.log("Processed data for chart:", processedData); // Debug log
    const labels = processedData.map(d => d.label);
    const focusedData = processedData.map(d => d.focused);
    const breakData = processedData.map(d => d.break);
    console.log("Chart Labels:", labels); // Debug log
    console.log("Chart Focused Data:", focusedData); // Debug log
    console.log("Chart Break Data:", breakData); // Debug log

    if (recordsChart) {
        recordsChart.destroy(); // Destroy existing chart before creating a new one
    }

    recordsChart = new Chart(recordsChartCanvas, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: '集中時間 (分)',
                    data: focusedData,
                    backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(),
                    borderRadius: 6, // More rounded bars
                    barPercentage: 0.8, // Adjust bar width
                    categoryPercentage: 0.8 // Adjust space between categories
                },
                {
                    label: '休憩時間 (分)',
                    data: breakData,
                    backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--secondary-period-color').trim(),
                    borderRadius: 6, // More rounded bars
                    barPercentage: 0.8,
                    categoryPercentage: 0.8
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y + '分';
                            }
                            return label;
                        }
                    },
                    bodyFont: {
                        family: 'Inter, sans-serif',
                        size: 14
                    },
                    titleFont: {
                        family: 'Inter',
                        size: 16,
                        weight: 'bold'
                    }
                },
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        font: {
                            size: 15,
                            family: 'Inter',
                            weight: '500'
                        },
                        color: 'var(--on-surface)'
                    }
                },
                title: {
                    display: true,
                    text: getChartTitle(timeUnit),
                    font: {
                        size: 20,
                        family: 'Inter',
                        weight: '700'
                    },
                    color: 'var(--on-surface)'
                }
            },
            scales: {
                x: {
                    stacked: false, // Changed to false for parallel bars
                    grid: {
                        display: false
                    },
                    ticks: {
                        font: {
                            family: 'Inter',
                            size: 13
                        },
                        color: 'var(--on-surface)'
                    },
                    title: {
                        display: true,
                        text: getXAxisTitle(timeUnit),
                        font: {
                            family: 'Inter',
                            weight: '600',
                            size: 14
                        },
                        color: 'var(--on-surface)'
                    }
                },
                y: {
                    stacked: false, // Changed to false for parallel bars
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return value + '分';
                        },
                        font: {
                            family: 'Inter',
                            size: 13
                        },
                        color: 'var(--on-surface)'
                    },
                    grid: {
                        color: 'var(--grid-color)' /* Grid line color from theme */
                    },
                    title: {
                        display: true,
                        text: '時間 (分)',
                        font: {
                            family: 'Inter',
                            weight: '600',
                            size: 14
                        },
                        color: 'var(--on-surface)'
                    }
                }
            }
        }
    });

    // Adjust chart canvas width for daily view if many days
    if (timeUnit === 'day' && labels.length > 7) {
        // Since bars are now parallel, they take up more horizontal space per category
        recordsChartCanvas.style.minWidth = `${labels.length * 100}px`; // Increased from 65px to 100px for parallel bars
    } else {
        recordsChartCanvas.style.minWidth = 'unset';
    }
}

function processRecordsForChart(records, timeUnit) {
    const dataMap = new Map();

    records.forEach(record => {
        const date = new Date(record.date);
        let key;
        let label;

        // Ensure date object for consistent key/label generation
        const recordDate = new Date(record.date);

        if (timeUnit === 'day') {
            key = recordDate.toISOString().split('T')[0]; // budou-MM-DD
            label = `${recordDate.getMonth() + 1}/${recordDate.getDate()}`; // M/D
        } else if (timeUnit === 'month') {
            key = `${recordDate.getFullYear()}-${String(recordDate.getMonth() + 1).padStart(2, '0')}`; // budou-MM
            label = `${recordDate.getMonth() + 1}月`;
        } else if (timeUnit === 'year') {
            key = String(recordDate.getFullYear()); // budou
            label = `${recordDate.getFullYear()}年`;
        }

        // Store key along with other data
        if (!dataMap.has(key)) {
            dataMap.set(key, { focused: 0, break: 0, label: label, date: recordDate, key: key });
        }
        const entry = dataMap.get(key);
        entry.focused = (entry.focused || 0) + record.focusedMinutes; // Ensure initialization
        entry.break = (entry.break || 0) + record.breakMinutes; // Ensure initialization
    });

    // Convert map values to array and sort by date
    const sortedData = Array.from(dataMap.values()).sort((a, b) => a.date.getTime() - b.date.getTime());

    const filledData = [];
    if (sortedData.length > 0) {
        let currentDate = new Date(sortedData[0].date); // Start from the earliest record date

        // Ensure currentDate is correctly initialized to the start of the period for consistent filling
        if (timeUnit === 'month') {
            currentDate.setDate(1); // Set to 1st day of the month
        } else if (timeUnit === 'year') {
            currentDate.setMonth(0, 1); // Set to Jan 1st
        }


        const endDate = new Date(sortedData[sortedData.length - 1].date); // End at the latest record date

        // Adjust endDate to include the full last period if it's month/year
        if (timeUnit === 'month') {
            endDate.setMonth(endDate.getMonth() + 1, 0); // last day of month (sets to last day of current month)
        } else if (timeUnit === 'year') {
            endDate.setFullYear(endDate.getFullYear(), 11, 31); // last day of year (Dec 31st)
        }

        while (currentDate <= endDate) {
            let keyToFind;
            let labelToSet;
            let tempDateForComparison = new Date(currentDate); // Use a temporary date for comparison to avoid mutating currentDate

            if (timeUnit === 'day') {
                keyToFind = tempDateForComparison.toISOString().split('T')[0];
                labelToSet = `${tempDateForComparison.getMonth() + 1}/${tempDateForComparison.getDate()}`;
            } else if (timeUnit === 'month') {
                keyToFind = `${tempDateForComparison.getFullYear()}-${String(tempDateForComparison.getMonth() + 1).padStart(2, '0')}`;
                labelToSet = `${tempDateForComparison.getMonth() + 1}月`;
            } else if (timeUnit === 'year') {
                keyToFind = String(tempDateForComparison.getFullYear());
                labelToSet = `${tempDateForComparison.getFullYear()}年`;
            }

            const foundEntry = sortedData.find(d => d.key === keyToFind);

            if (foundEntry) {
                filledData.push(foundEntry);
            } else {
                // Push a new entry with 0 focused/break time for missing periods
                filledData.push({ focused: 0, break: 0, label: labelToSet, date: new Date(tempDateForComparison), key: keyToFind });
            }

            // Increment currentDate for the next iteration
            if (timeUnit === 'day') {
                currentDate.setDate(currentDate.getDate() + 1);
            } else if (timeUnit === 'month') {
                currentDate.setMonth(currentDate.getMonth() + 1);
            } else if (timeUnit === 'year') {
                currentDate.setFullYear(currentDate.getFullYear() + 1);
            }
        }
    }

    return filledData;
}

function getChartTitle(timeUnit) {
    switch (timeUnit) {
        case 'day': return '日別集中・休憩時間';
        case 'month': return '月別集中・休憩時間';
        case 'year': return '年別集中・休憩時間';
        default: return '集中・休憩時間の記録';
    }
}

function getXAxisTitle(timeUnit) {
    switch (timeUnit) {
        case 'day': return '日付';
        case 'month': return '月';
        case 'year': return '年';
        default: return '単位';
    }
}

dailyViewButton.addEventListener('click', () => {
    currentChartTimeUnit = 'day';
    dailyViewButton.classList.add('active');
    monthlyViewButton.classList.remove('active');
    yearlyViewButton.classList.remove('active');
    renderRecordsChart(currentChartTimeUnit);
});

monthlyViewButton.addEventListener('click', () => {
    currentChartTimeUnit = 'month';
    monthlyViewButton.classList.add('active');
    dailyViewButton.classList.remove('active');
    yearlyViewButton.classList.remove('active');
    renderRecordsChart(currentChartTimeUnit);
});

yearlyViewButton.addEventListener('click', () => {
    currentChartTimeUnit = 'year';
    yearlyViewButton.classList.add('active');
    dailyViewButton.classList.remove('active');
    monthlyViewButton.classList.remove('active');
    renderRecordsChart(currentChartTimeUnit);
});


// --- Initial Setup ---
document.addEventListener('DOMContentLoaded', async () => {
    // Load app theme from localStorage and apply it
    appTheme = localStorage.getItem('pomodoroAppTheme') || 'system';
    setAppTheme(appTheme);

    // Apply saved accent theme color
    themeColor = localStorage.getItem('pomodoroThemeColor') || '#ef4444';
    // Initially set the theme color input to the loaded value
    themeColorInput.value = themeColor;
    setThemeColors(themeColor); // This will update the active primary colors based on current appTheme

    // Set initial clock format for home screen
    if (clockFormat === '24') {
        clockFormat24.checked = true;
    } else {
        clockFormat12.checked = true;
    }

    // Set initial clock display format for home screen
    clockDisplayFormat = localStorage.getItem('pomodoroClockDisplayFormat') || 'digital';
    if (clockDisplayFormat === 'digital') {
        clockDisplayFormatDigital.checked = true;
    } else {
        clockDisplayFormatAnalog.checked = true;
    }
    setClockDisplayMode(clockDisplayFormat); // Set the initial display mode

    // Initialize display with current work time (for timer screen)
    resetTimer(); // Use resetTimer to initialize currentTimeInSeconds and remainingTimeAtLastStart
    updateDisplay();

    // Show home screen initially (clock update handled by setClockDisplayMode)
    showScreen('home');

    // Load custom alarm sounds
    await openIndexedDB(); // Open DB when DOM is ready
    await loadAlarmSoundsToSelect();

    // Add a global click listener to unlock audio for browsers
    // that require user interaction for audio playback.
    document.body.addEventListener('click', unlockAudio, { once: true });
});

// Add a resize observer to redraw analog clock if container size changes
const resizeObserver = new ResizeObserver(entries => {
    for (let entry of entries) {
        if (entry.target === homeClockContainer && clockDisplayFormat === 'analog') {
            setClockDisplayMode('analog'); // Re-draw to adjust for new size
        }
    }
});
resizeObserver.observe(homeClockContainer);

    </script>
  </body>
</html>
